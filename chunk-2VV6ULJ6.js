"use strict";Object.defineProperty(exports, "__esModule", {value: true}); function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { newObj[key] = obj[key]; } } } newObj.default = obj; return newObj; } } function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }var _chunkQTVIWU3Njs = require('./chunk-QTVIWU3N.js');var _react = require('react'); var _react2 = _interopRequireDefault(_react);var _zustand = require('zustand');var pt=_zustand.create.call(void 0, ()=>({status:"disconnected"})),fe=()=>pt.getState().onNeedsRecovery,Or= exports.f =e=>{_react.useEffect.call(void 0, ()=>{pt.setState({onNeedsRecovery:e==null?void 0:e.onNeedsRecovery})},[e==null?void 0:e.onNeedsRecovery])};var _expocrypto = require('expo-crypto');var _jssdkcore = require('@privy-io/js-sdk-core'); var _jssdkcore2 = _interopRequireDefault(_jssdkcore);var yt={name:"@privy-io/expo",version:"0.63.5",description:"Expo client for the Privy Auth API",keywords:["authentication","authorization","identity","privacy","privy","user data","react-native","expo","web3"],homepage:"https://docs.privy.io",bugs:{url:"https://privy.io/slack"},license:"Apache-2.0",author:"privy.io",exports:{".":{require:"./dist/index.js",import:"./dist/esm/index.js",types:"./dist/index.d.ts"},"./passkey":{require:"./dist/passkey.js",import:"./dist/esm/passkey.js",types:"./dist/passkey.d.ts"},"./smart-wallets":{require:"./dist/smart-wallets.js",import:"./dist/esm/smart-wallets.js",types:"./dist/smart-wallets.d.ts"},"./extended-chains":{require:"./dist/extended-chains.js",import:"./dist/esm/extended-chains.js",types:"./dist/extended-chains.d.ts"},"./ui":{require:"./dist/ui.js",import:"./dist/esm/ui.js",types:"./dist/ui.d.ts"},"./connectors":{require:"./dist/connectors.js",import:"./dist/esm/connectors.js",types:"./dist/connectors.d.ts"}},main:"./dist/esm/index.js",source:"./src/index.ts",types:"./dist/index.d.ts",files:["dist/**/*","LICENSE","README.md"],scripts:{build:"tsup --clean --minify","check-types":"tsc --noEmit",clean:"rm -rf dist .turbo","clean:reset":"rm -rf dist .turbo node_modules",dev:"tsup --watch",format:'eslint "src/**/*.{ts,tsx,js,jsx}" --fix',"generate-types":"tsup --dts-only",lint:'eslint "src/**/*.{ts,tsx,js,jsx}"',test:"jest"},browserslist:["defaults","node >= 18","not op_mini all"],dependencies:{"@privy-io/api-types":"0.5.0","@privy-io/js-sdk-core":"workspace:*","@scure/base":"^1.2.4","react-fast-compare":"^3.2.2",tweetnacl:"^1.0.3",zustand:"^5.0.4"},devDependencies:{"@privy-io/eslint-config-custom":"workspace:*","@privy-io/eslint-plugin-privy-rules":"workspace:*","@privy-io/tsconfig":"workspace:*","@simplewebauthn/types":"9.0.1","@solana/web3.js":"^1.98.0","@svgr/core":"^8.1.0","@svgr/plugin-jsx":"^8.1.0","@svgr/plugin-svgo":"^8.1.0","@testing-library/react-native":"^13.1.0","@tsconfig/node16-strictest-esm":"^1.0.3","@types/jest":"^29.1.2","@types/react":"^18.3.18",buffer:"^5.4.3","eslint-plugin-react-hooks":"^5.0.0-canary-7118f5dd7-20230705",expo:"52.0.37","expo-apple-authentication":"7.1.3","expo-application":"6.0.2","expo-clipboard":"7.0.1","expo-crypto":"14.0.2",jest:"^29.7.0","jest-expo":"52.0.5","lucide-react-native":"^0.474.0",react:"^18.3.1","react-native":"0.77.1","react-test-renderer":"^18.3.1",tsup:"^6.2.3",typescript:"~5.5.3"},peerDependencies:{"@expo-google-fonts/inter":"*","@privy-io/expo-native-extensions":"workspace:*","expo-apple-authentication":"*","expo-application":"*","expo-clipboard":"*","expo-crypto":"*","expo-font":"*","expo-linking":"*","expo-secure-store":"*","expo-web-browser":"*",permissionless:"^0.2.47",react:"*","react-native":"*","react-native-passkeys":"^0.3.0","react-native-qrcode-styled":"0.3.3","react-native-safe-area-context":"*","react-native-svg":"*","react-native-webview":"*",viem:"^2.46.1"},peerDependenciesMeta:{"@expo-google-fonts/inter":{optional:!0},"expo-font":{optional:!0},permissionless:{optional:!0},viem:{optional:!0},"react-native-svg":{optional:!0},"expo-clipboard":{optional:!0},"react-native-qrcode-styled":{optional:!0},"react-native-safe-area-context":{optional:!0}},publishConfig:{access:"public"}};var ft=({appId:e,clientId:t,storage:r=_chunkQTVIWU3Njs.g,supportedChains:n,baseUrl:i,logLevel:o})=>new (0, _jssdkcore2.default)({appId:e,clientId:t,supportedChains:n,storage:_chunkQTVIWU3Njs.f.call(void 0, r),sdkVersion:`expo:${yt.version}`,nativeAppIdentifier:_chunkQTVIWU3Njs.e.call(void 0, ),crypto:{digest:_expocrypto.digest},baseUrl:i,logLevel:o});var _reactnative = require('react-native');var _reactfastcompare = require('react-fast-compare'); var _reactfastcompare2 = _interopRequireDefault(_reactfastcompare);var ge=_zustand.create.call(void 0, ()=>{}),gt=e=>ge.setState(t=>_reactfastcompare2.default.call(void 0, t,e)?t:e),W= exports.a =ge.getState;var _reactnativewebview = require('react-native-webview'); var _reactnativewebview2 = _interopRequireDefault(_reactnativewebview);var _exposecurestore = require('expo-secure-store'); var F = _interopRequireWildcard(_exposecurestore);function ht(e){return typeof e!="object"||e===null||!("event"in e&&typeof e.event=="string")||!("id"in e&&typeof e.id=="string")||!("data"in e&&typeof e.data=="object")||e.data===null?!1:e.event.startsWith("app:secure-storage:")}function wt(e){return _chunkQTVIWU3Njs.d.call(void 0, this,null,function*(){switch(e.event){case"app:secure-storage:get":{let{key:t}=e.data,r=yield F.getItemAsync(Oe(t),{keychainAccessible:F.AFTER_FIRST_UNLOCK_THIS_DEVICE_ONLY}).catch(n=>(console.warn("Failed to get the value from secure store",n),null));return{event:e.event,id:e.id,data:{value:r}}}case"app:secure-storage:remove":{let{key:t}=e.data,r=yield F.deleteItemAsync(Oe(t),{keychainAccessible:F.AFTER_FIRST_UNLOCK_THIS_DEVICE_ONLY}).then(()=>!0).catch(n=>(console.warn("Failed to remove the value from secure store",n),!1));return{event:e.event,id:e.id,data:{success:r}}}case"app:secure-storage:set":{let{key:t,value:r}=e.data,n=yield F.setItemAsync(Oe(t),r,{keychainAccessible:F.AFTER_FIRST_UNLOCK_THIS_DEVICE_ONLY}).then(()=>!0).catch(i=>(console.warn("Failed to write the value to secure store",i),!1));return{event:e.event,id:e.id,data:{success:n}}}}})}var Oe=e=>e.replaceAll(":","-");var j=_zustand.createStore.call(void 0, )(()=>({user:null,proxyStatus:"loading"}));function b(){return j.getState().user}var qi=j.subscribe.bind(j);function Me(e){j.setState(({user:t})=>_reactfastcompare2.default.call(void 0, t,e)?{}:{user:e})}var Fe=e=>j.setState({proxyStatus:e});function U(){return _zustand.useStore.call(void 0, j,e=>e.user)}function Gi(){return _zustand.useStore.call(void 0, j,e=>!!e.user)}function V(){return _zustand.useStore.call(void 0, j,e=>e.proxyStatus!=="loading")}var Gr={shouldUseAppBackedStorage:!0},vt=({client:e,isClientReady:t})=>{let r=_react.useRef.call(void 0, null);_react.useEffect.call(void 0, ()=>_reactnative.AppState.addEventListener("change",o=>_chunkQTVIWU3Njs.d.call(void 0, void 0,null,function*(){o==="active"&&((yield e.embeddedWallet.ping(500))||(Fe("reloading"),e.embeddedWallet.reload()))})).remove,[e]);let n=_react.useCallback.call(void 0, i=>_chunkQTVIWU3Njs.d.call(void 0, void 0,null,function*(){var s;let{data:o}=i.nativeEvent,a=JSON.parse(o);if(ht(a)){let d=yield wt(a);(s=r.current)==null||s.postMessage(JSON.stringify(d));return}e.embeddedWallet.onMessage(a)}),[e]);return t?_react2.default.createElement(_reactnativewebview2.default,{style:{flex:1},ref:i=>{i&&(e.setMessagePoster(i),r.current=i)},cacheEnabled:!1,cacheMode:"LOAD_NO_CACHE",injectedJavaScriptObject:Gr,source:{uri:e.embeddedWallet.getURL()},webviewDebuggingEnabled:e.logger.level==="DEBUG",onLoad:()=>Fe("loaded"),onError:console.error,onMessage:n}):null};function St(o){return _chunkQTVIWU3Njs.d.call(void 0, this,arguments,function*({client:e,setSolanaWallet:t,createSolanaWalletCallbacks:r,setSolanaRecoveryFlowState:n,opts:i}){var a,s,d;t({status:"creating"});try{let{user:c}=yield e.user.get(),u=_jssdkcore.getAllUserEmbeddedSolanaWallets.call(void 0, c),m=u[0],p=(a=_jssdkcore.getUserEmbeddedEthereumWallet.call(void 0, c))!=null?a:void 0;if(i!=null&&i.recoveryMethod&&i.recoveryMethod!=="privy")throw new (0, _jssdkcore.PrivyClientError)({code:"embedded_wallet_creation_error",error:"Unsupported recovery method for solana wallet."});if(!(i!=null&&i.createAdditional)&&m)throw new (0, _jssdkcore.PrivyClientError)({code:"embedded_wallet_creation_error",error:"Solana wallet already exists for this user. Set `createAdditional` to `true` to create another wallet"});let w,g;if(m){let y=p!=null?p:m,{entropyId:h,entropyIdVerifier:S}=_jssdkcore.getEntropyDetailsFromAccount.call(void 0, y),_=Math.max(...u.map(x=>x.wallet_index),0)+1,C=yield e.embeddedWallet.add({chainType:"solana",entropyId:h,entropyIdVerifier:S,hdWalletIndex:_}),k=_jssdkcore.getAllUserEmbeddedSolanaWallets.call(void 0, C.user).find(x=>x.wallet_index===_);if(!k)throw new (0, _jssdkcore.PrivyClientError)({error:"Embedded wallet account not created",code:"embedded_wallet_creation_error"});w=yield e.embeddedWallet.getSolanaProvider(k,h,S),g=C.user}else{let y=yield e.embeddedWallet.createSolana({ethereumAccount:p}),h=_jssdkcore.getAllUserEmbeddedSolanaWallets.call(void 0, y.user).find(k=>k.wallet_index===0);if(!h)throw new (0, _jssdkcore.PrivyClientError)({error:"Embedded wallet account not created",code:"embedded_wallet_creation_error"});let S=p!=null?p:h,{entropyId:_,entropyIdVerifier:C}=_jssdkcore.getEntropyDetailsFromAccount.call(void 0, S);w=yield e.embeddedWallet.getSolanaProvider(h,_,C),g=y.user}let v=_jssdkcore.getAllUserEmbeddedSolanaWallets.call(void 0, g)[0];if(!v)throw new (0, _jssdkcore.PrivyClientError)({code:"embedded_wallet_creation_error",error:"Unknown error creating solana wallet"});return(d=(s=r.current)==null?void 0:s.onSuccess)==null||d.call(s,w),t({status:"connected",publicKey:v.public_key}),n({status:"initial"}),w}catch(c){let u=c instanceof Error?c.message:"Error creating embedded wallet";throw t({status:"error",error:u}),n({status:"initial"}),new (0, _jssdkcore.PrivyClientError)({code:"embedded_wallet_creation_error",error:u})}})}function we(u){return _chunkQTVIWU3Njs.d.call(void 0, this,arguments,function*({client:e,account:t,setWallet:r,recoverWalletCallbacks:n,recoveryMethod:i,setRecoveryFlowState:o,password:a,recoveryKey:s,recoveryToken:d,recoverySecretOverride:c}){var m,p,w,g;if(!t)throw new (0, _jssdkcore.PrivyClientError)({code:"embedded_wallet_does_not_exist",error:"Embedded wallet does not exist"});switch(i){case"user-passcode":if(!a)throw new (0, _jssdkcore.PrivyClientError)({code:"embedded_wallet_recovery_error",error:"password is required for user-passcode recovery method"});break;case"google-drive":if(!d)throw new (0, _jssdkcore.PrivyClientError)({code:"embedded_wallet_recovery_error",error:"Recovery token is required for google-drive recovery method"});break;case"icloud":if(!c)throw new (0, _jssdkcore.PrivyClientError)({code:"embedded_wallet_recovery_error",error:"Record name is required for icloud recovery method"});break;case"recovery-encryption-key":if(!s)throw new (0, _jssdkcore.PrivyClientError)({code:"embedded_wallet_recovery_error",error:"recoveryKey is required for recovery-encryption-key recovery method"});break}r({status:"connecting",account:t});try{let v=yield e.embeddedWallet.getProvider(t,a,d,c,s);return r({status:"connected",provider:v,account:t}),o({status:"initial"}),(p=(m=n.current)==null?void 0:m.onSuccess)==null||p.call(m,v),v}catch(v){r({status:"needs-recovery",account:t}),o({status:"initial"});let y=new (0, _jssdkcore.PrivyClientError)({code:"embedded_wallet_recovery_error",error:v instanceof Error?v.message:"Error recovering embedded wallet"});throw(g=(w=n.current)==null?void 0:w.onError)==null||g.call(w,y),y}})}function Et(s){return _chunkQTVIWU3Njs.d.call(void 0, this,arguments,function*({client:e,account:t,entropyId:r,entropyIdVerifier:n,setSolanaWallet:i,recoverSolanaWalletCallbacks:o,setSolanaRecoveryFlowState:a}){var d,c,u,m;i({status:"connecting"});try{let p=yield e.embeddedWallet.getSolanaProvider(t,r,n);return i({status:"connected",publicKey:p._publicKey}),a({status:"initial"}),(c=(d=o.current)==null?void 0:d.onSuccess)==null||c.call(d,p),p}catch(p){i({status:"needs-recovery"}),a({status:"initial"});let w=new (0, _jssdkcore.PrivyClientError)({code:"embedded_wallet_recovery_error",error:p instanceof Error?p.message:"Error recovering embedded wallet"});throw(m=(u=o.current)==null?void 0:u.onError)==null||m.call(u,w),w}})}var kt=({client:e,solanaWallet:t,setSolanaWallet:r,setSolanaRecoveryFlowState:n,createSolanaWalletCallbacks:i,recoverSolanaWalletCallbacks:o})=>{let a=U(),s=_react.useMemo.call(void 0, ()=>_jssdkcore.getAllUserEmbeddedSolanaWallets.call(void 0, a),[a]),d=V(),c=_react.useMemo.call(void 0, ()=>s.length===0?null:_jssdkcore.getEntropyDetailsFromUser.call(void 0, a),[a,s]),u=_react.useMemo.call(void 0, ()=>{let g=s.map(S=>{let _=_jssdkcore.getEntropyDetailsFromUser.call(void 0, a,S);return _?{account:S,entropy:_}:null});if(g.some(S=>S===null))return[];let v=void 0,y=void 0,h=void 0;return g.filter(S=>S!==null).map(({account:S,entropy:{entropyId:_,entropyIdVerifier:C}})=>({address:S.address,publicKey:S.address,walletIndex:S.wallet_index,getProvider:()=>e.embeddedWallet.getSolanaProvider(S,_,C,v,y,h,k=>_chunkQTVIWU3Njs.d.call(void 0, void 0,null,function*(){var x;yield(x=fe())==null?void 0:x(k)}))}))},[s,a,e]),m=_react.useCallback.call(void 0, g=>_chunkQTVIWU3Njs.d.call(void 0, void 0,null,function*(){return yield St({client:e,setSolanaWallet:r,createSolanaWalletCallbacks:i,setSolanaRecoveryFlowState:n,opts:g})}),[e,i]),p=_react.useCallback.call(void 0, ()=>_chunkQTVIWU3Njs.d.call(void 0, void 0,null,function*(){if(!c)throw new (0, _jssdkcore.PrivyClientError)({code:"embedded_wallet_does_not_exist",error:"Embedded wallet does not exist"});let{entropyId:g,entropyIdVerifier:v}=c;return Et({client:e,account:s[0],entropyId:g,entropyIdVerifier:v,setSolanaWallet:r,recoverSolanaWalletCallbacks:o,setSolanaRecoveryFlowState:n})}),[e,c,s,o,n,r]),w=_react.useCallback.call(void 0, ()=>_chunkQTVIWU3Njs.d.call(void 0, void 0,null,function*(){if(!c)throw r({status:"not-created"}),new (0, _jssdkcore.PrivyClientError)({code:"embedded_wallet_does_not_exist",error:"Embedded wallet does not exist"});r(g=>g.status==="connected"?{status:"reconnecting"}:{status:"connecting"});try{let{entropyId:g,entropyIdVerifier:v}=c,y=yield e.embeddedWallet.getSolanaProvider(s[0],g,v);return r({status:"connected",publicKey:s[0].public_key}),y}catch(g){throw _jssdkcore.errorIndicatesRecoveryIsNeeded.call(void 0, g)?(r({status:"needs-recovery"}),new (0, _jssdkcore.PrivyClientError)({code:"embedded_wallet_needs_recovery",error:"Embedded wallet not loaded on device"})):g instanceof Error?(r({status:"error",error:g.message}),new (0, _jssdkcore.PrivyClientError)({code:"unknown_embedded_wallet_error",error:g.message})):(r({status:"error",error:"Error loading embedded wallet"}),new (0, _jssdkcore.PrivyClientError)({code:"unknown_embedded_wallet_error",error:"Error loading embedded wallet"}))}}),[s,e,c,r]);return _react.useEffect.call(void 0, ()=>{if(!a&&t.status!=="disconnected")return r({status:"disconnected"});d&&w().catch(()=>{})},[d,a]),_react.useEffect.call(void 0, ()=>{t.status==="error"&&t.error.includes("User must be logged in")&&w()},[t.status]),{create:m,recover:p,getProvider:w,wallets:u}};function ve(m){return _chunkQTVIWU3Njs.d.call(void 0, this,arguments,function*({client:e,setWallet:t,createWalletCallbacks:r,recoveryMethod:n,setRecoveryFlowState:i,password:o,recoveryKey:a,recoveryToken:s,recoverySecretOverride:d,iCloudRecordNameOverride:c,solanaAccount:u}){var w,g;switch(n){case"user-passcode":if(!o)throw new (0, _jssdkcore.PrivyClientError)({code:"embedded_wallet_recovery_error",error:"password is required for user-passcode recovery method"});break;case"recovery-encryption-key":if(!a)throw new (0, _jssdkcore.PrivyClientError)({code:"embedded_wallet_recovery_error",error:"key is required for recovery-encryption-key recovery method"});break;case"google-drive":if(!s)throw new (0, _jssdkcore.PrivyClientError)({code:"embedded_wallet_recovery_error",error:"Recovery token is required for google-drive recovery method"});break;case"icloud":if(!d||!c)throw new (0, _jssdkcore.PrivyClientError)({code:"embedded_wallet_recovery_error",error:"iCloud recovery failed due to inability to store credentials"});break}t({status:"creating",account:null});let p=n==="icloud"?"icloud-native":n;try{let{user:v}=yield e.embeddedWallet.create({password:o,recoveryMethod:p,recoveryKey:a,recoveryToken:s,recoverySecretOverride:d,iCloudRecordNameOverride:c,solanaAccount:u}),y=_jssdkcore.getUserEmbeddedEthereumWallet.call(void 0, v);if(!y)throw new (0, _jssdkcore.PrivyClientError)({error:"Embedded wallet account not created",code:"embedded_wallet_creation_error"});let h=yield e.embeddedWallet.getProvider(y);return(g=(w=r.current)==null?void 0:w.onSuccess)==null||g.call(w,h),t({status:"connected",provider:h,account:y}),i({status:"initial"}),h}catch(v){let y=v instanceof Error?v.message:"Error creating embedded wallet";throw t({status:"error",error:y,account:null}),i({status:"initial"}),new (0, _jssdkcore.PrivyClientError)({code:"embedded_wallet_creation_error",error:y})}})}function xt(){return _chunkQTVIWU3Njs.d.call(void 0, this,null,function*(){try{return yield Promise.resolve().then(() => _interopRequireWildcard(require("@privy-io/expo-native-extensions")))}catch(e){throw new Error("@privy-io/expo-native-extensions not found. Ensure that you're explicitly including as a dependency, and running an Expo development build")}})}function oe(n){return _chunkQTVIWU3Njs.d.call(void 0, this,arguments,function*({user:e,appId:t,client:r}){var s;if(_reactnative.Platform.OS==="android")throw new (0, _jssdkcore.PrivyClientError)({code:"embedded_wallet_recovery_error",error:"iCloud recovery is not supported on Android"});let i=yield xt(),o=yield r.recovery.icloudAuth.getICloudConfiguration("expo-ios");if(!(o==null?void 0:o.container_identifier))throw new (0, _jssdkcore.PrivyClientError)({code:"embedded_wallet_recovery_error",error:"An iCloud Container ID must be specified in the Privy Dashboard."});try{let{recoverySecret:d,iCloudRecordName:c}=yield i.writeRecoverySecretToICloud({containerId:o.container_identifier,appId:t,userId:e.id});return{recoverySecret:d,iCloudRecordName:c}}catch(d){if(d instanceof Error){let c=(s=d.message.split("Caused by: ")[1])!=null?s:"Error writing to iCloud";throw new (0, _jssdkcore.PrivyClientError)({code:"embedded_wallet_recovery_error",error:c})}throw new (0, _jssdkcore.PrivyClientError)({code:"embedded_wallet_recovery_error",error:"Error writing to iCloud"})}})}function be(n){return _chunkQTVIWU3Njs.d.call(void 0, this,arguments,function*({walletAddress:e,client:t,chainType:r}){var c;if(_reactnative.Platform.OS==="android")throw new (0, _jssdkcore.PrivyClientError)({code:"embedded_wallet_recovery_error",error:"iCloud recovery is not supported on Android"});let i=yield xt(),a=(yield t.recovery.getRecoveryKeyMaterial(e,r)).icloud_record_name;if(!a)throw new (0, _jssdkcore.PrivyClientError)({code:"embedded_wallet_recovery_error",error:"iCloud recovery not properly backed up."});let s=yield t.recovery.icloudAuth.getICloudConfiguration("expo-ios"),d=s==null?void 0:s.container_identifier;if(!d)throw new (0, _jssdkcore.PrivyClientError)({code:"embedded_wallet_recovery_error",error:"An iCloud Container ID must be specified in the Privy Dashboard."});try{let{recoverySecret:u}=yield i.readRecoverySecretFromICloud({containerId:d,recordName:a});return{recoverySecret:u}}catch(u){if(u instanceof Error){let m=(c=u.message.split("Caused by: ")[1])!=null?c:"Error writing to iCloud";throw new (0, _jssdkcore.PrivyClientError)({code:"embedded_wallet_recovery_error",error:m})}throw new (0, _jssdkcore.PrivyClientError)({code:"embedded_wallet_recovery_error",error:"Error writing to iCloud"})}})}var _expolinking = require('expo-linking'); var z = _interopRequireWildcard(_expolinking); var $ = _interopRequireWildcard(_expolinking); var ke = _interopRequireWildcard(_expolinking); var We = _interopRequireWildcard(_expolinking); var tr = _interopRequireWildcard(_expolinking); var er = _interopRequireWildcard(_expolinking); var rr = _interopRequireWildcard(_expolinking); var nr = _interopRequireWildcard(_expolinking); var ar = _interopRequireWildcard(_expolinking); var cr = _interopRequireWildcard(_expolinking);var _expowebbrowser = require('expo-web-browser'); var Pt = _interopRequireWildcard(_expowebbrowser); var ce = _interopRequireWildcard(_expowebbrowser);function E(e){return e instanceof Error||e instanceof _jssdkcore.PrivyApiError||e instanceof _jssdkcore.PrivyClientError?e:typeof e=="string"?new Error(e):new Error("Unknown error")}var G=e=>new Promise(t=>setTimeout(t,e));function Se(){let e=_react.useRef.call(void 0, _reactnative.AppState.currentState);_react.useEffect.call(void 0, ()=>_reactnative.AppState.addEventListener("change",n=>{e.current=n}).remove,[]);function t(){return _reactnative.AppState.currentState}return{appState:e,getCurrentAppState:t}}function ne(i){return _chunkQTVIWU3Njs.d.call(void 0, this,arguments,function*({provider:e,redirectUri:t,client:r,onError:n}){try{let o;switch(e){case"google-drive":{let{url:c}=yield r.recovery.auth.generateURL(z.createURL(t||"/"));o=c;break}default:throw new (0, _jssdkcore.PrivyClientError)({error:"OAuth invalid provider",code:"embedded_wallet_recovery_error"})}let a=yield Pt.openAuthSessionAsync(o);if(_reactnative.Platform.OS==="android")return;if(a.type!=="success")throw new (0, _jssdkcore.PrivyClientError)({error:"Recovery OAuth session failed",code:"embedded_wallet_recovery_error"});let{queryParams:s}=z.parse(a.url),d;switch(e){case"google-drive":{let{privy_oauth_state:c,privy_oauth_code:u}=s;if(!u||!c)throw new (0, _jssdkcore.PrivyClientError)({error:"Recovery OAuth invalid credentials",code:"embedded_wallet_recovery_error"});d=yield Ee({oAuthCode:u,oAuthState:c,client:r});break}default:throw new (0, _jssdkcore.PrivyClientError)({error:"Recovery OAuth invalid provider",code:"embedded_wallet_recovery_error"})}return d}catch(o){throw n==null||n(E(o)),o}})}function Ee(n){return _chunkQTVIWU3Njs.d.call(void 0, this,arguments,function*({oAuthCode:e,oAuthState:t,client:r}){let{access_token:i}=yield r.recovery.auth.authorize(e,t);if(!i)throw new (0, _jssdkcore.PrivyClientError)({error:"OAuth invalid credentials",code:"login_with_oauth_returned_with_invalid_credentials"});return i})}var ro=2*60*1e3;function oo(e){let t;return new Promise((r,n)=>{t=z.addEventListener("url",o=>_chunkQTVIWU3Njs.d.call(void 0, this,[o],function*({url:i}){if(!i)return;let{queryParams:a}=z.parse(i),{privy_oauth_state:s,privy_oauth_code:d}=a!=null?a:{};if(typeof d!="string"||typeof s!="string")return;let c=yield Ee({client:e,oAuthCode:d,oAuthState:s});r(c)})),setTimeout(()=>{n(new (0, _jssdkcore.PrivyClientError)({code:"embedded_wallet_set_recovery_error",error:"Failed to complete Google Drive recovery flow"}))},ro)}).finally(()=>{t==null||t.remove()})}function _e(e){return _chunkQTVIWU3Njs.d.call(void 0, this,null,function*(){let t;_reactnative.Platform.OS==="android"&&(t=oo(e));let r=yield ne({provider:"google-drive",client:e});return r!=null?r:yield t})}function Ce(o){return _chunkQTVIWU3Njs.d.call(void 0, this,arguments,function*({client:e,recoveryInput:t,setWalletRecoveryCallbacks:r,setRecoveryFlowState:n,setWallet:i}){var a,s,d,c;try{let{provider:u,user:m}=yield e.embeddedWallet.setRecovery(t),p=u,w=_jssdkcore.getUserEmbeddedWallet.call(void 0, m);return i({status:"connected",provider:p,account:w}),(s=(a=r.current)==null?void 0:a.onSuccess)==null||s.call(a,p),n({status:"initial"}),p}catch(u){let m=new (0, _jssdkcore.PrivyClientError)({code:"embedded_wallet_set_recovery_error",error:u instanceof Error?u.message:"Error setting password on embedded wallet"});throw(c=(d=r.current)==null?void 0:d.onError)==null||c.call(d,m),n({status:"initial"}),m}})}function It(e){return e===void 0?{recoveryMethod:"privy"}:typeof e=="string"?{recoveryMethod:"user-passcode",password:e}:e.recoveryMethod==="user-passcode"?{recoveryMethod:"user-passcode",password:e.password}:e.recoveryMethod==="recovery-encryption-key"?{recoveryMethod:"recovery-encryption-key",recoveryKey:e.recoveryKey}:{recoveryMethod:e.recoveryMethod}}var Ot=({client:e,appId:t,wallet:r,setWallet:n,setRecoveryFlowState:i,createWalletCallbacks:o,recoverWalletCallbacks:a,setWalletRecoveryCallbacks:s})=>{let d=U(),c=_react.useMemo.call(void 0, ()=>_jssdkcore.getUserEmbeddedEthereumWallet.call(void 0, d),[d]),u=V(),m=_react.useCallback.call(void 0, y=>_chunkQTVIWU3Njs.d.call(void 0, void 0,null,function*(){var ue,me;if(c)throw new (0, _jssdkcore.PrivyClientError)({error:"This user already has an embedded wallet",code:"embedded_wallet_already_exists"});let{user:h}=yield e.user.get(),{password:S,recoveryMethod:_,recoveryKey:C}=It(y),k,x,M;if(_==="google-drive"&&(k=yield ne({provider:_,client:e,onError:(ue=o.current)==null?void 0:ue.onError}),i({status:"creating-wallet"}),!k))return null;if(_==="icloud"){if(!h)throw new (0, _jssdkcore.PrivyClientError)({code:"embedded_wallet_recovery_error",error:"User must be loaded before creating a wallet with iCloud."});let{recoverySecret:Ae,iCloudRecordName:te}=yield oe({user:h,appId:t,client:e});x=Ae,M=te}return yield ve({client:e,setWallet:n,createWalletCallbacks:o,recoveryMethod:_,recoveryKey:C,setRecoveryFlowState:i,password:S,recoverySecretOverride:x,iCloudRecordNameOverride:M,solanaAccount:(me=_jssdkcore.getUserEmbeddedSolanaWallet.call(void 0, h))!=null?me:void 0})}),[e,c,d]),p=_react.useCallback.call(void 0, y=>_chunkQTVIWU3Njs.d.call(void 0, void 0,null,function*(){var _;if(r.status!=="connected")throw new (0, _jssdkcore.PrivyClientError)({code:"attempted_to_set_password_before_connected",error:"Embedded wallet must be connected before setting password"});if(!c)throw new (0, _jssdkcore.PrivyClientError)({code:"embedded_wallet_does_not_exist",error:"Embedded wallet does not exist"});if(_jssdkcore.getUserEmbeddedSolanaWallet.call(void 0, d))throw new (0, _jssdkcore.PrivyClientError)({code:"embedded_wallet_set_recovery_error",error:"Cannot set user-controlled recovery for a user with an embedded Solana wallet."});if(_jssdkcore.isUnifiedWallet.call(void 0, c))throw new (0, _jssdkcore.PrivyClientError)({code:"unsupported_wallet_type",error:"Embedded wallet recovery is only supported for on-device execution and this app uses TEE execution. Learn more https://docs.privy.io/recipes/tee-wallet-migration-guide"});_jssdkcore.throwIfInvalidRecoveryUpgradePath.call(void 0, {currentRecoveryMethod:c.recovery_method,upgradeToRecoveryMethod:y.recoveryMethod});let h,S;switch(y.recoveryMethod){case"privy":S=_chunkQTVIWU3Njs.b.call(void 0, _chunkQTVIWU3Njs.a.call(void 0, {},y),{wallet:c});break;case"user-passcode":S=_chunkQTVIWU3Njs.b.call(void 0, _chunkQTVIWU3Njs.a.call(void 0, {},y),{wallet:c,password:y.password});break;case"google-drive":if(h=yield ne({provider:y.recoveryMethod,client:e,onError:(_=s.current)==null?void 0:_.onError}),i({status:"upgrading-recovery"}),!h)return null;S={recoveryMethod:"google-drive",wallet:c,recoveryAccessToken:h};break;case"icloud":if(!d)throw new (0, _jssdkcore.PrivyClientError)({code:"embedded_wallet_recovery_error",error:"User must be loaded before backing up to iCloud."});let{recoverySecret:C,iCloudRecordName:k}=yield oe({user:d,appId:t,client:e});S={recoveryMethod:"icloud-native",recoverySecretOverride:C,iCloudRecordNameOverride:k,wallet:c};break;default:throw new (0, _jssdkcore.PrivyClientError)({code:"embedded_wallet_recovery_error",error:"Unrecognized recovery method"})}return Ce({client:e,recoveryInput:S,setWalletRecoveryCallbacks:s,setRecoveryFlowState:i,setWallet:n})}),[e,c,r.status,d]),w=_react.useCallback.call(void 0, y=>_chunkQTVIWU3Njs.d.call(void 0, void 0,null,function*(){return p({recoveryMethod:"user-passcode",password:y})}),[e,c,r.status]),g=_react.useCallback.call(void 0, y=>_chunkQTVIWU3Njs.d.call(void 0, void 0,null,function*(){var x;if(!c)throw new (0, _jssdkcore.PrivyClientError)({code:"embedded_wallet_does_not_exist",error:"Embedded wallet does not exist"});let{password:h,recoveryMethod:S,recoveryKey:_}=It(y),C,k;if(S==="google-drive"&&(C=yield ne({provider:S,client:e,onError:(x=a.current)==null?void 0:x.onError}),i({status:"recovering"}),!C))return null;if(S==="icloud"){if(!d)throw new (0, _jssdkcore.PrivyClientError)({code:"embedded_wallet_recovery_error",error:"User must be loaded before recovering via iCloud."});let{recoverySecret:M}=yield be({client:e,walletAddress:c.address});k=M}return we({client:e,account:c,setWallet:n,recoverWalletCallbacks:a,recoveryMethod:S,setRecoveryFlowState:i,recoveryKey:_,password:h,recoveryToken:C,recoverySecretOverride:k})}),[e,c]),v=_react.useCallback.call(void 0, ()=>_chunkQTVIWU3Njs.d.call(void 0, void 0,null,function*(){if(!c)throw n({status:"not-created",account:null}),new (0, _jssdkcore.PrivyClientError)({code:"embedded_wallet_does_not_exist",error:"Embedded wallet does not exist"});n(y=>y.status==="connected"?{status:"reconnecting",account:c}:{status:"connecting",account:c});try{let y=yield e.embeddedWallet.getProvider(c);return n({status:"connected",provider:y,account:c}),y}catch(y){throw _jssdkcore.errorIndicatesRecoveryIsNeeded.call(void 0, y)?(n({status:"needs-recovery",account:c}),new (0, _jssdkcore.PrivyClientError)({code:"embedded_wallet_needs_recovery",error:"Embedded wallet not loaded on device"})):y instanceof Error?(n({status:"error",error:y.message,account:c}),new (0, _jssdkcore.PrivyClientError)({code:"unknown_embedded_wallet_error",error:y.message})):(n({status:"error",error:"Error loading embedded wallet",account:c}),new (0, _jssdkcore.PrivyClientError)({code:"unknown_embedded_wallet_error",error:"Error loading embedded wallet"}))}}),[e,c]);return _react.useEffect.call(void 0, ()=>{if(!d&&r.status!=="disconnected")return n({status:"disconnected",account:null});u&&v().catch(()=>{})},[u,d,c]),_react.useEffect.call(void 0, ()=>{r.status==="error"&&r.error.includes("User must be logged in")&&v()},[r.status]),{create:m,recover:g,setPassword:w,setRecovery:p,getProvider:v}};var Mt=({client:e,isReady:t})=>{let r=U(),n=ge(a=>a==null?void 0:a.customAuth),[i,o]=_react.useState.call(void 0, {status:"initial"});return _react.useEffect.call(void 0, ()=>{(()=>_chunkQTVIWU3Njs.d.call(void 0, void 0,null,function*(){if(!(n!=null&&n.enabled)){o({status:"not-enabled"});return}o({status:"loading"});let{getCustomAccessToken:s,isLoading:d}=n;if(!(!t||d))try{let c=yield s();if(!c&&r){yield e.auth.logout(),o({status:"done"});return}if(!c){o({status:"done"});return}if(r){o({status:"done"});return}let u=W();if(!(yield e.auth.customProvider.syncWithToken(c,{embedded:u==null?void 0:u.embedded}))){yield e.auth.logout(),o({status:"error",error:new (0, _jssdkcore.PrivyClientError)({error:"Failed to sync with custom auth provider",code:"third_party_auth_error"})});return}o({status:"done"})}catch(c){if(console.log("Error syncing with custom auth provider",c),o({status:"error",error:c}),r)throw yield e.auth.logout(),new (0, _jssdkcore.PrivyClientError)({error:"Third-party auth failed",code:"third_party_auth_error"})}}))()},[e,r,t,n==null?void 0:n.enabled,n==null?void 0:n.getCustomAccessToken,n==null?void 0:n.isLoading]),{customAuthState:i,customAuthStateIsSettled:i.status!=="loading"&&i.status!=="initial"}};var Ft=({client:e,createWalletCallbacks:t,recoverWalletCallbacks:r,setWalletRecoveryCallbacks:n,recoveryFlowState:i,oAuthState:o,setRecoveryFlowState:a,setWallet:s,appStateVisible:d})=>{let c=$.useURL(),u=U(),m=_react.useMemo.call(void 0, ()=>_jssdkcore.getUserEmbeddedWallet.call(void 0, u),[u]),p=V(),w=_react.useCallback.call(void 0, g=>{var y,h,S,_;let v=E(g);i.status==="creating-wallet"?(h=(y=t.current).onError)==null||h.call(y,E(v)):(_=(S=r.current).onError)==null||_.call(S,E(v)),a({status:"initial"})},[i]);return _react.useEffect.call(void 0, ()=>{function g(){return _chunkQTVIWU3Njs.d.call(void 0, this,null,function*(){var S;if(!c&&i.status!=="initial"&&d&&w(new Error("Recovery OAuth session failed")),!c||i.status==="initial"||o.status!=="initial"||!d||!p)return;let{queryParams:v}=$.parse(c),{privy_oauth_state:y,privy_oauth_code:h}=v;if(!(!h||!y)){yield $.openURL(c.split("?")[0]);try{let _=yield Ee({oAuthCode:h,oAuthState:y,client:e});if(i.status==="creating-wallet"){let C=(S=_jssdkcore.getUserEmbeddedSolanaWallet.call(void 0, u))!=null?S:void 0;yield ve({client:e,setWallet:s,createWalletCallbacks:t,recoveryMethod:"google-drive",setRecoveryFlowState:a,recoveryToken:_,solanaAccount:C})}else if(i.status==="upgrading-recovery"){if(!m)throw new Error("Embedded wallet not found");yield Ce({client:e,recoveryInput:{recoveryMethod:"google-drive",wallet:m,recoveryAccessToken:_},setWalletRecoveryCallbacks:n,setRecoveryFlowState:a,setWallet:s})}else yield we({client:e,account:m,setWallet:s,recoverWalletCallbacks:r,recoveryMethod:"google-drive",setRecoveryFlowState:a,recoveryToken:_})}catch(_){w(_)}}})}_reactnative.Platform.OS==="android"&&g()},[c,i.status,d,p])};var Tt=({client:e,isUserInitialized:t,setIsUserInitialized:r,setError:n})=>{_react.useEffect.call(void 0, ()=>{t||(()=>_chunkQTVIWU3Njs.d.call(void 0, void 0,null,function*(){try{yield e.initialize()}catch(o){n(o instanceof Error?o:new Error(String(o)))}try{yield e.user.get()}catch(o){}finally{r(!0)}}))()},[e,t,n,r])};var Is=e=>{let{client:t,setSiweState:r,siweState:n}=_react.useContext.call(void 0, f),i=_react.useCallback.call(void 0, s=>{var c;let d=E(s);return r({status:"error",error:d}),(c=e==null?void 0:e.onError)==null||c.call(e,d),d},[e==null?void 0:e.onError]),o=_react.useCallback.call(void 0, u=>_chunkQTVIWU3Njs.d.call(void 0, void 0,[u],function*({wallet:s,from:{domain:d,uri:c}}){var m;try{r({status:"generating-message"});let p=yield t.auth.siwe.init(s,d,c);return r({status:"awaiting-signature"}),(m=e==null?void 0:e.onGenerateMessage)==null||m.call(e,p.message),p.message}catch(p){throw i(p)}}),[t,i,e==null?void 0:e.onGenerateMessage]);return{loginWithSiwe:_react.useCallback.call(void 0, u=>_chunkQTVIWU3Njs.d.call(void 0, void 0,[u],function*({signature:s,messageOverride:d,disableSignup:c}){var m;try{if(b())throw new (0, _jssdkcore.PrivyClientError)({code:"attempted_login_with_siwe_while_already_logged_in",error:"Already logged in, use `useLinkWithSiwe` if you are trying to link a wallet to an existing account"});r({status:"submitting-signature"});let w=W(),g=yield t.auth.siwe.loginWithSiwe(s,void 0,d,c?"no-signup":"login-or-sign-up",{embedded:w==null?void 0:w.embedded});return r({status:"done"}),(m=e==null?void 0:e.onSuccess)==null||m.call(e,g.user,g.is_new_user),g.user}catch(p){throw i(p)}}),[t,i,e==null?void 0:e.onSuccess]),generateSiweMessage:o,state:n}};var O=()=>{let{client:e}=_react.useContext.call(void 0, f);return e};var Bs=()=>{let e=O(),t=_react.useCallback.call(void 0, a=>_chunkQTVIWU3Njs.d.call(void 0, void 0,[a],function*({wallet:{address:n},from:{domain:i,uri:o}}){try{let{nonce:s}=yield e.auth.siws.fetchNonce({address:n});return{message:_jssdkcore.createSiwsMessage.call(void 0, {address:n,domain:i,uri:o,nonce:s})}}catch(s){throw E(s)}}),[e]),r=_react.useCallback.call(void 0, s=>_chunkQTVIWU3Njs.d.call(void 0, void 0,[s],function*({signature:n,message:i,wallet:{walletClientType:o,connectorType:a}={}}){try{if(!b())throw new (0, _jssdkcore.PrivyClientError)({code:"attempted_link_siws_before_logged_in",error:"Must be logged in to link a wallet, Use `useLoginWithSiws` to login with a wallet"});let{user:c}=yield e.auth.siws.link({signature:n,message:i,walletClientType:o,connectorType:a});return c}catch(d){throw E(d)}}),[e]);return{generateMessage:t,link:r}};var Xs=()=>{let e=O(),t=_react.useCallback.call(void 0, a=>_chunkQTVIWU3Njs.d.call(void 0, void 0,[a],function*({wallet:{address:n},from:{domain:i,uri:o}}){try{let{nonce:s}=yield e.auth.siws.fetchNonce({address:n});return{message:_jssdkcore.createSiwsMessage.call(void 0, {address:n,domain:i,uri:o,nonce:s})}}catch(s){throw E(s)}}),[e]),r=_react.useCallback.call(void 0, d=>_chunkQTVIWU3Njs.d.call(void 0, void 0,[d],function*({signature:n,message:i,wallet:{walletClientType:o,connectorType:a}={},disableSignup:s}){try{if(b())throw new (0, _jssdkcore.PrivyClientError)({code:"attempted_login_with_siws_while_already_logged_in",error:"Already logged in, use `useLinkWithSiws` if you are trying to link a wallet to an existing account"});let u=W();return(yield e.auth.siws.login({signature:n,message:i,walletClientType:o,connectorType:a,mode:s?"no-signup":"login-or-sign-up",opts:{embedded:u==null?void 0:u.embedded}})).user}catch(c){throw E(c)}}),[e]);return{generateMessage:t,login:r}};var ac=e=>{let{client:t}=_react.useContext.call(void 0, f),r=_react.useCallback.call(void 0, i=>{var a;let o=E(i);return(a=e==null?void 0:e.onError)==null||a.call(e,o),o},[e==null?void 0:e.onError]);return{unlinkWallet:_react.useCallback.call(void 0, o=>_chunkQTVIWU3Njs.d.call(void 0, void 0,[o],function*({address:i}){var a;try{if(!b())throw new (0, _jssdkcore.PrivyClientError)({code:"attempted_unlink_siwe_before_logged_in",error:"Must be logged in to unlink a wallet, Use `useLoginWithSiwe` to login with a wallet"});let{user:d}=yield t.auth.siwe.unlinkWallet(i);return(a=e==null?void 0:e.onSuccess)==null||a.call(e,d),d}catch(s){throw r(s)}}),[t,r,e==null?void 0:e.onSuccess])}};var yc=e=>{let[t,r]=_react.useState.call(void 0, ""),{client:n,otpState:i,setOtpState:o}=_react.useContext.call(void 0, f),a=_react.useCallback.call(void 0, c=>{var m;let u=E(c);return o({status:"error",error:u}),(m=e==null?void 0:e.onError)==null||m.call(e,u),u},[e,o]),s=_react.useCallback.call(void 0, u=>_chunkQTVIWU3Njs.d.call(void 0, void 0,[u],function*({email:c}){var m;r(c);try{o({status:"sending-code"});let p=yield n.auth.email.sendCode(c);return o({status:"awaiting-code-input"}),(m=e==null?void 0:e.onSendCodeSuccess)==null||m.call(e,{email:c}),p}catch(p){throw a(p)}}),[n,a,e,o]),d=_react.useCallback.call(void 0, m=>_chunkQTVIWU3Njs.d.call(void 0, void 0,[m],function*({code:c,email:u}){var p;try{if(!b())throw new (0, _jssdkcore.PrivyClientError)({code:"attempted_link_email_before_logged_in",error:"Must be logged in to link an email, Use `useLoginWithEmail` to login with email"});let g=u||t;if(!g)throw new (0, _jssdkcore.PrivyClientError)({code:"attempted_submit_otp_before_sending",error:"Must `sendCode` with a valid email before calling `linkWithCode`"});o({status:"submitting-code"});let{user:v}=yield n.auth.email.linkWithCode(g,c);return o({status:"done"}),(p=e==null?void 0:e.onLinkSuccess)==null||p.call(e,v),v}catch(w){throw a(w)}}),[t,o,n,e,a]);return{sendCode:s,linkWithCode:d,state:i}};var bc=e=>{let{client:t}=_react.useContext.call(void 0, f),r=_react.useCallback.call(void 0, i=>{var a;let o=E(i);return(a=e==null?void 0:e.onError)==null||a.call(e,o),o},[e==null?void 0:e.onError]);return{unlinkEmail:_react.useCallback.call(void 0, o=>_chunkQTVIWU3Njs.d.call(void 0, void 0,[o],function*({email:i}){var a;try{let{user:s}=yield t.auth.email.unlink(i);return(a=e==null?void 0:e.onSuccess)==null||a.call(e,s),s}catch(s){throw r(s)}}),[t,e==null?void 0:e.onSuccess,r])}};var Uc=e=>{let[t,r]=_react.useState.call(void 0, ""),{client:n,otpState:i,setOtpState:o}=_react.useContext.call(void 0, f),a=_react.useCallback.call(void 0, c=>{var m;let u=E(c);return o({status:"error",error:u}),(m=e==null?void 0:e.onError)==null||m.call(e,u),u},[e,o]),s=_react.useCallback.call(void 0, u=>_chunkQTVIWU3Njs.d.call(void 0, void 0,[u],function*({email:c}){var m;r(c);try{o({status:"sending-code"});let p=yield n.auth.email.sendCode(c);return o({status:"awaiting-code-input"}),(m=e==null?void 0:e.onSendCodeSuccess)==null||m.call(e,{email:c}),p}catch(p){throw a(p)}}),[n,a,e,o]),d=_react.useCallback.call(void 0, p=>_chunkQTVIWU3Njs.d.call(void 0, void 0,[p],function*({code:c,email:u,disableSignup:m}){var w;try{if(b())throw new (0, _jssdkcore.PrivyClientError)({code:"attempted_login_with_email_while_already_logged_in",error:"Already logged in, use `useLinkWithEmail` if you are trying to link an email to an existing account"});let v=u||t;if(!v)throw new (0, _jssdkcore.PrivyClientError)({code:"attempted_submit_otp_before_sending",error:"Must `sendCode` with a valid email before calling `loginWithCode`"});o({status:"submitting-code"});let y=W(),h=yield n.auth.email.loginWithCode(v,c,m?"no-signup":"login-or-sign-up",{embedded:y==null?void 0:y.embedded});return o({status:"done"}),(w=e==null?void 0:e.onLoginSuccess)==null||w.call(e,h.user,h.is_new_user),h==null?void 0:h.user}catch(g){throw a(g)}}),[t,o,n,e,a]);return{sendCode:s,loginWithCode:d,state:i}};var Tc=e=>{let[t,r]=_react.useState.call(void 0, ""),{client:n,otpState:i,setOtpState:o}=_react.useContext.call(void 0, f),a=_react.useCallback.call(void 0, c=>{var m;let u=E(c);return o({status:"error",error:u}),(m=e==null?void 0:e.onError)==null||m.call(e,u),u},[e,o]),s=_react.useCallback.call(void 0, u=>_chunkQTVIWU3Njs.d.call(void 0, void 0,[u],function*({phone:c}){var m;r(c);try{o({status:"sending-code"});let p=yield n.auth.phone.sendCode(c);return o({status:"awaiting-code-input"}),(m=e==null?void 0:e.onSendCodeSuccess)==null||m.call(e,{phone:c}),p}catch(p){throw a(p)}}),[n,a,e,o]),d=_react.useCallback.call(void 0, m=>_chunkQTVIWU3Njs.d.call(void 0, void 0,[m],function*({code:c,phone:u}){var p;try{if(!b())throw new (0, _jssdkcore.PrivyClientError)({code:"attempted_link_sms_before_logged_in",error:"Must be logged in to link a phone number, Use `useLoginWithSMS` to login with a phone number"});if(!(u||t))throw new (0, _jssdkcore.PrivyClientError)({code:"attempted_submit_otp_before_sending",error:"Must `sendCode` with a valid phone number before calling `linkWithCode`"});o({status:"submitting-code"});let{user:v}=yield n.auth.phone.linkWithCode(u||t,c);return o({status:"done"}),(p=e==null?void 0:e.onLinkSuccess)==null||p.call(e,v),v}catch(w){throw a(w)}}),[t,o,n,e,a]);return{sendCode:s,linkWithCode:d,state:i}};var qc=e=>{let[t,r]=_react.useState.call(void 0, ""),{client:n,otpState:i,setOtpState:o}=_react.useContext.call(void 0, f),a=_react.useCallback.call(void 0, c=>{var m;let u=E(c);return o({status:"error",error:u}),(m=e==null?void 0:e.onError)==null||m.call(e,u),u},[e,o]),s=_react.useCallback.call(void 0, u=>_chunkQTVIWU3Njs.d.call(void 0, void 0,[u],function*({phone:c}){var m;r(c);try{o({status:"sending-code"});let p=yield n.auth.phone.sendCode(c);return o({status:"awaiting-code-input"}),(m=e==null?void 0:e.onSendCodeSuccess)==null||m.call(e,{phone:c}),p}catch(p){throw a(p)}}),[n,a,e,o]),d=_react.useCallback.call(void 0, p=>_chunkQTVIWU3Njs.d.call(void 0, void 0,[p],function*({code:c,phone:u,disableSignup:m}){var w;try{if(b())throw new (0, _jssdkcore.PrivyClientError)({code:"attempted_login_with_sms_while_already_logged_in",error:"Already logged in, use `useLinkWithSMS` if you are trying to link a phone number to an existing account"});if(!(u||t))throw new (0, _jssdkcore.PrivyClientError)({code:"attempted_submit_otp_before_sending",error:"Must `sendCode` with a valid phone number before calling `loginWithCode`"});o({status:"submitting-code"});let y=W(),h=yield n.auth.phone.loginWithCode(u||t,c,m?"no-signup":"login-or-sign-up",{embedded:y==null?void 0:y.embedded});return o({status:"done"}),(w=e==null?void 0:e.onLoginSuccess)==null||w.call(e,h.user,h.is_new_user),h==null?void 0:h.user}catch(g){throw a(g)}}),[t,o,n,e,a]);return{sendCode:s,loginWithCode:d,state:i}};var ed=e=>{let{appState:t,getCurrentAppState:r}=Se(),{client:n,farcasterState:i,setFarcasterState:o}=_react.useContext.call(void 0, f),a=_react.useRef.call(void 0, !1),s=_react.useCallback.call(void 0, u=>{var p;let m=E(u);return o({status:"error",error:m}),(p=e==null?void 0:e.onError)==null||p.call(e,m),m},[e==null?void 0:e.onError,o]),d=_react.useCallback.call(void 0, ()=>{a.current=!0},[]);return{linkWithFarcaster:_react.useCallback.call(void 0, (w,...g)=>_chunkQTVIWU3Njs.d.call(void 0, void 0,[w,...g],function*({relyingParty:u,redirectUrl:m},p={pollAttempts:10,pollIntervalMs:1e3}){var v;try{let y=b();if(a.current=!1,!y)throw new (0, _jssdkcore.PrivyClientError)({code:"attempted_link_farcaster_before_logged_in",error:"Must be logged in to link a Farcaster account."});o({status:"generating-uri"});let{connect_uri:h,channel_token:S}=yield n.auth.farcaster.initializeAuth({relyingParty:u,redirectUrl:ke.createURL(m!=null?m:"/")});if(!h)throw new (0, _jssdkcore.PrivyClientError)({code:"failed_to_generate_farcaster_uri",error:"Failed to generate farcaster uri"});if(!S)throw new (0, _jssdkcore.PrivyClientError)({code:"failed_to_generate_farcaster_channel_token",error:"Failed to generate farcaster channel token"});yield ke.openURL(h),o({status:"polling-status"});let _=0;for(;_<p.pollAttempts;){if(a.current)throw new (0, _jssdkcore.PrivyClientError)({code:"farcaster_polling_canceled",error:"Farcaster polling canceled"});if(t.current!=="active"&&r()!=="active"){yield G(p.pollIntervalMs);continue}let C=yield n.auth.farcaster.getFarcasterStatus({channel_token:S});if(C.state==="completed"){o({status:"submitting-token"});let{user:k}=yield n.auth.farcaster.link(_chunkQTVIWU3Njs.a.call(void 0, {channel_token:S},C));return o({status:"done"}),(v=e==null?void 0:e.onSuccess)==null||v.call(e,k),k}_++,yield G(p.pollIntervalMs)}throw new (0, _jssdkcore.PrivyClientError)({code:"farcaster_polling_timeout",error:"Farcasting polling timed out"})}catch(y){throw s(y)}}),[n,e==null?void 0:e.onSuccess,s,o]),state:i,cancel:d}};var ad=e=>{let{client:t}=_react.useContext.call(void 0, f),r=_react.useCallback.call(void 0, i=>{var a;let o=E(i);return(a=e==null?void 0:e.onError)==null||a.call(e,o),o},[e==null?void 0:e.onError]);return{unlinkFarcaster:_react.useCallback.call(void 0, o=>_chunkQTVIWU3Njs.d.call(void 0, void 0,[o],function*({fid:i}){var a;try{let{user:s}=yield t.auth.farcaster.unlink({fid:i});return(a=e==null?void 0:e.onSuccess)==null||a.call(e,s),s}catch(s){throw r(s)}}),[t,e==null?void 0:e.onSuccess,r])}};var fd=e=>{let{appState:t,getCurrentAppState:r}=Se(),{client:n,farcasterState:i,setFarcasterState:o}=_react.useContext.call(void 0, f),a=_react.useRef.call(void 0, !1),s=_react.useCallback.call(void 0, u=>{var p;let m=E(u);return o({status:"error",error:m}),(p=e==null?void 0:e.onError)==null||p.call(e,m),m},[e==null?void 0:e.onError,o]),d=_react.useCallback.call(void 0, ()=>{a.current=!0},[]);return{loginWithFarcaster:_react.useCallback.call(void 0, (g,...v)=>_chunkQTVIWU3Njs.d.call(void 0, void 0,[g,...v],function*({relyingParty:u,redirectUrl:m,disableSignup:p},w={pollAttempts:10,pollIntervalMs:1e3}){var y;try{if(a.current=!1,b())throw new (0, _jssdkcore.PrivyClientError)({code:"attempted_login_with_farcaster_while_already_logged_in",error:"Already logged in, use `useLinkWithFarcaster` if you are trying to link farcaster to an existing account"});o({status:"generating-uri"});let{connect_uri:S,channel_token:_}=yield n.auth.farcaster.initializeAuth({relyingParty:u,redirectUrl:We.createURL(m!=null?m:"/")});if(!S)throw new (0, _jssdkcore.PrivyClientError)({code:"failed_to_generate_farcaster_uri",error:"Failed to generate farcaster uri"});if(!_)throw new (0, _jssdkcore.PrivyClientError)({code:"failed_to_generate_farcaster_channel_token",error:"Failed to generate farcaster channel token"});yield We.openURL(S),o({status:"polling-status"});let C=0;for(;C<w.pollAttempts;){if(a.current)throw new (0, _jssdkcore.PrivyClientError)({code:"farcaster_polling_canceled",error:"Farcaster polling canceled"});if(t.current!=="active"&&r()!=="active"){yield G(w.pollIntervalMs);continue}let k=yield n.auth.farcaster.getFarcasterStatus({channel_token:_});if(k.state==="completed"){o({status:"submitting-token"});let x=W(),M=yield n.auth.farcaster.authenticate(_chunkQTVIWU3Njs.a.call(void 0, {channel_token:_,mode:p?"no-signup":"login-or-sign-up"},k),{embedded:x==null?void 0:x.embedded});return o({status:"done"}),(y=e==null?void 0:e.onSuccess)==null||y.call(e,M.user,M.is_new_user),M.user}C++,yield G(w.pollIntervalMs)}throw new (0, _jssdkcore.PrivyClientError)({code:"farcaster_polling_timeout",error:"Farcasting polling timed out"})}catch(h){throw s(h)}}),[n,s,e==null?void 0:e.onSuccess,o,t]),state:i,cancel:d}};var $e=_zustand.create.call(void 0, ()=>({status:"initial"})),K=e=>$e.setState(e,!0),Go=$e.getState,kd= exports.x =()=>{let{client:e}=_react.useContext.call(void 0, f),t=$e(),r=_react.useCallback.call(void 0, ()=>_chunkQTVIWU3Njs.d.call(void 0, void 0,null,function*(){try{K({status:"fetching-nonce"});let i=yield e.auth.farcasterV2.initializeAuth();return K({status:"awaiting-signature"}),i}catch(i){let o=E(i);throw K({status:"initial",error:o}),o}}),[e]),n=_react.useCallback.call(void 0, i=>_chunkQTVIWU3Njs.d.call(void 0, void 0,null,function*(){let o=Go().status;try{if(b()){let c=new (0, _jssdkcore.PrivyClientError)({code:"attempted_login_with_farcaster_while_already_logged_in",error:"Already logged in, use a link helper if you are trying to link farcaster to an existing account"});throw K({status:o,error:c}),c}K({status:"submitting-signature"});let s=W(),d=yield e.auth.farcasterV2.authenticate(i,{embedded:s==null?void 0:s.embedded});return K({status:"done"}),setTimeout(()=>K({status:"initial"}),1500),{user:d.user}}catch(a){let s=E(a);throw K({status:o,error:s}),s}}),[e]);return{init:r,login:n,state:t}};var Rd=()=>{let{client:e}=_react.useContext.call(void 0, f);return _react.useMemo.call(void 0, ()=>({delegateWallet:_jssdkcore.delegatedActions.delegateWallet(e),revokeWallets:_jssdkcore.delegatedActions.revokeWallets(e)}),[e])};function Qo(e,t){return e.linked_accounts.filter(_jssdkcore.isEmbeddedWalletAccount).find(r=>r.address===t)}function Y(e){let t=b();if(!t)throw new Error("User must be authenticated to perform this operation");let r=Qo(t,e);if(!r)throw new Error(`No wallet found with address ${e}`);return r}var jd=()=>{let{client:e}=_react.useContext.call(void 0, f);return _react.useMemo.call(void 0, ()=>({addSessionSigners:({address:t,signers:r})=>_jssdkcore.addSessionSigners.call(void 0, {client:e,wallet:Y(t),signers:r.map(n=>({signer_id:n.signerId,override_policy_ids:n.policyIds}))}),removeSessionSigners:({address:t})=>_jssdkcore.removeSessionSigners.call(void 0, {client:e,wallet:Y(t)})}),[e])};var qd=()=>{let{client:e}=_react.useContext.call(void 0, f);return _react.useMemo.call(void 0, ()=>({addSigners:({address:t,signers:r})=>_jssdkcore.addSessionSigners.call(void 0, {client:e,wallet:Y(t),signers:r.map(n=>({signer_id:n.signerId,override_policy_ids:n.policyIds}))}),removeSigners:({address:t})=>_jssdkcore.removeSessionSigners.call(void 0, {client:e,wallet:Y(t)})}),[e])};var Xd=()=>{let{client:e}=_react.useContext.call(void 0, f);return _react.useMemo.call(void 0, ()=>({sendCode(n){return _chunkQTVIWU3Njs.d.call(void 0, this,arguments,function*({newEmailAddress:r}){$t(),yield e.auth.email.sendCode(r)})},updateEmail(i){return _chunkQTVIWU3Njs.d.call(void 0, this,arguments,function*({newEmailAddress:r,code:n}){let{address:o}=$t(),{user:a}=yield e.auth.email.updateEmail({oldEmailAddress:o,newEmailAddress:r,code:n});return a})}}),[e])};function $t(){let t=dn().linked_accounts.find(r=>r.type==="email");if(!t)throw new (0, _jssdkcore.PrivyClientError)({code:"attempted_update_email_without_a_linked_email",error:"Must have a linked email account already to update an email address. Use `useLinkEmail` to link an email account."});return t}function dn(){let e=b();if(!e)throw new (0, _jssdkcore.PrivyClientError)({code:"attempted_update_before_logged_in",error:"Must be logged in to update a user profile."});return e}var il=()=>{let{client:e}=_react.useContext.call(void 0, f);return _react.useMemo.call(void 0, ()=>({sendCode(n){return _chunkQTVIWU3Njs.d.call(void 0, this,arguments,function*({newPhoneNumber:r}){Qt(),yield e.auth.phone.sendCode(r)})},updatePhone(i){return _chunkQTVIWU3Njs.d.call(void 0, this,arguments,function*({newPhoneNumber:r,code:n}){let{phoneNumber:o}=Qt(),{user:a}=yield e.auth.phone.updatePhone({oldPhoneNumber:o,newPhoneNumber:r,code:n});return a})}}),[e])};function Qt(){let t=mn().linked_accounts.find(r=>r.type==="phone");if(!t)throw new (0, _jssdkcore.PrivyClientError)({code:"attempted_update_phone_without_a_linked_phone",error:"Must have a linked phone account already to update a phone number. Use `useLinkSMS` to link a phone number."});return t}function mn(){let e=b();if(!e)throw new (0, _jssdkcore.PrivyClientError)({code:"attempted_update_before_logged_in",error:"Must be logged in to update a user profile."});return e}var T=(e,t)=>_chunkQTVIWU3Njs.d.call(void 0, void 0,null,function*(){let r=yield ce.openAuthSessionAsync(e,t,{createTask:!1});if(r.type!=="success")throw r.type===ce.WebBrowserResultType.CANCEL||r.type===ce.WebBrowserResultType.DISMISS?new (0, _jssdkcore.PrivyClientError)({error:"OAuth session was cancelled",code:"oauth_session_failed"}):new (0, _jssdkcore.PrivyClientError)({error:"OAuth session failed",code:"oauth_session_failed"});return pn(r.url)});function pn(e){let{queryParams:t}=er.parse(e);return t}var gl=()=>{let{client:e}=_react.useContext.call(void 0, f),t=_react.useMemo.call(void 0, ()=>_jssdkcore.crossApp.loginWithCrossAppAuth({client:e,openAuthSession:T}),[e]);return{loginWithCrossApp:_react.useCallback.call(void 0, o=>_chunkQTVIWU3Njs.d.call(void 0, void 0,[o],function*({appId:n,redirectUri:i}){if(b())throw new (0, _jssdkcore.PrivyClientError)({code:"attempted_login_with_cross_app_while_already_logged_in",error:"Already logged in, use `linkCrossAppAccount` if you are trying to link a cross app account to an existing account"});let{user:s}=yield t({providerAppId:n,redirectUrl:tr.createURL(i||"/")});return{user:s}}),[t])}};var Cl=()=>{let{client:e}=_react.useContext.call(void 0, f),t=_react.useMemo.call(void 0, ()=>_jssdkcore.crossApp.linkWithCrossAppAuth({client:e,openAuthSession:T}),[e]);return{linkWithCrossApp:_react.useCallback.call(void 0, o=>_chunkQTVIWU3Njs.d.call(void 0, void 0,[o],function*({appId:n,redirectUri:i}){if(!b())throw new (0, _jssdkcore.PrivyClientError)({code:"attempted_link_cross_app_before_logged_in",error:"Must be logged in to link a cross app account, Use `loginWithCrossAppAccount` to login with cross app"});return{user:yield t({providerAppId:n,redirectUrl:rr.createURL(i||"/")})}}),[t])}};var Il=()=>{let{client:e}=_react.useContext.call(void 0, f),t=_react.useMemo.call(void 0, ()=>_jssdkcore.crossApp.wallet.signMessage({client:e,openAuthSession:T}),[e]);return _react.useMemo.call(void 0, ()=>({signMessage:({address:r,message:n,redirectUri:i="/"})=>t({user:b(),address:r,message:n,redirectUrl:nr.createURL(i)})}),[t])};var Dl=()=>{let{client:e}=_react.useContext.call(void 0, f),t=_react.useMemo.call(void 0, ()=>_jssdkcore.crossApp.wallet.signTypedData({client:e,openAuthSession:T}),[e]);return _react.useMemo.call(void 0, ()=>({signTypedData:({address:r,typedData:n,redirectUri:i="/"})=>t({user:b(),address:r,typedData:n,redirectUrl:ar.createURL(i)})}),[t])};var ql=()=>{let{client:e}=_react.useContext.call(void 0, f),t=_react.useMemo.call(void 0, ()=>_jssdkcore.crossApp.wallet.sendTransaction({client:e,openAuthSession:T}),[e]);return _react.useMemo.call(void 0, ()=>({sendTransaction:({address:r,transaction:n,redirectUri:i="/"})=>t({user:b(),address:r,transaction:n,redirectUrl:cr.createURL(i)})}),[t])};var eu=()=>{let{client:e}=_react.useContext.call(void 0, f);return{setRecovery:_react.useCallback.call(void 0, r=>_chunkQTVIWU3Njs.d.call(void 0, void 0,null,function*(){var s;let n=b(),i=e.app.appId;if(!n)throw new (0, _jssdkcore.PrivyClientError)({code:"embedded_wallet_recovery_error",error:"User must be loaded before attempting to modify the recovery method."});let o=(s=_jssdkcore.getUserEmbeddedEthereumWallet.call(void 0, n))!=null?s:_jssdkcore.getUserEmbeddedSolanaWallet.call(void 0, n);if(!o)throw new (0, _jssdkcore.PrivyClientError)({code:"embedded_wallet_does_not_exist",error:"Embedded wallet does not exist"});if(_jssdkcore.isUnifiedWallet.call(void 0, o))throw new (0, _jssdkcore.PrivyClientError)({code:"unsupported_wallet_type",error:"Embedded wallet recovery is only supported for on-device execution and this app uses TEE execution. Learn more https://docs.privy.io/recipes/tee-wallet-migration-guide"});try{o.chain_type==="ethereum"?yield e.embeddedWallet.getProvider(o):o.chain_type==="solana"&&(yield e.embeddedWallet.getSolanaProvider(o,o.address,"solana-address-verifier"))}catch(d){throw new (0, _jssdkcore.PrivyClientError)({code:"attempted_to_set_password_before_connected",error:"Embedded wallet must be connected before setting password"})}_jssdkcore.throwIfInvalidRecoveryUpgradePath.call(void 0, {currentRecoveryMethod:o.recovery_method,upgradeToRecoveryMethod:r.recoveryMethod});let a=yield Fn({appId:i,client:e,user:n,primaryAccount:o,recoveryParams:r});try{let{user:d}=yield e.embeddedWallet.setRecovery(a);return{user:d}}catch(d){throw new (0, _jssdkcore.PrivyClientError)({code:"embedded_wallet_set_recovery_error",error:d instanceof Error?d.message:"Error setting password on embedded wallet"})}}),[e])}},Fn=o=>_chunkQTVIWU3Njs.d.call(void 0, void 0,[o],function*({appId:e,client:t,user:r,primaryAccount:n,recoveryParams:i}){switch(i.recoveryMethod){case"privy":return{recoveryMethod:"privy",wallet:n};case"user-passcode":return _chunkQTVIWU3Njs.b.call(void 0, _chunkQTVIWU3Njs.a.call(void 0, {},i),{wallet:n});case"google-drive":{let a=yield _e(t);return{recoveryMethod:"google-drive",wallet:n,recoveryAccessToken:a}}case"icloud":{let{recoverySecret:a,iCloudRecordName:s}=yield oe({appId:e,client:t,user:r});return{recoveryMethod:"icloud-native",recoverySecretOverride:a,iCloudRecordNameOverride:s,wallet:n}}case"recovery-encryption-key":return{recoveryMethod:"recovery-encryption-key",wallet:n,recoveryKey:i.recoveryKey};default:throw new (0, _jssdkcore.PrivyClientError)({code:"embedded_wallet_recovery_error",error:"Unrecognized recovery method"})}});var du=()=>{let{client:e}=_react.useContext.call(void 0, f);return{recover:_react.useCallback.call(void 0, r=>_chunkQTVIWU3Njs.d.call(void 0, void 0,null,function*(){var c;let n=b();if(!n)throw new (0, _jssdkcore.PrivyClientError)({code:"embedded_wallet_recovery_error",error:"User must be loaded before attempting to modify the recovery method."});let i=(c=_jssdkcore.getUserEmbeddedEthereumWallet.call(void 0, n))!=null?c:_jssdkcore.getUserEmbeddedSolanaWallet.call(void 0, n);if(!i)throw new (0, _jssdkcore.PrivyClientError)({code:"embedded_wallet_does_not_exist",error:"Embedded wallet does not exist"});if(_jssdkcore.isUnifiedWallet.call(void 0, i))throw new (0, _jssdkcore.PrivyClientError)({code:"unsupported_wallet_type",error:"User owned wallet recovery is only supported for on-device execution and this app uses TEE execution. Learn more https://docs.privy.io/recipes/tee-wallet-migration-guide"});let o,a,s,d;switch(r.recoveryMethod){case"user-passcode":a=r.password;break;case"google-drive":s=yield _e(e);break;case"icloud":let{recoverySecret:u}=yield be({client:e,walletAddress:i.address,chainType:i.chain_type});d=u;break;case"recovery-encryption-key":o=r.recoveryKey;break;case"privy":break;default:throw new (0, _jssdkcore.PrivyClientError)({code:"unsupported_recovery_method",error:`Unsupported recovery options ${r}`})}try{i.chain_type==="ethereum"?yield e.embeddedWallet.getProvider(i,a,s,d,o):i.chain_type==="solana"&&(yield e.embeddedWallet.getSolanaProvider(i,i.address,"solana-address-verifier",a,s,d))}catch(u){throw new (0, _jssdkcore.PrivyClientError)({code:"attempted_to_set_password_before_connected",error:"Embedded wallet must be connected before setting password"})}}),[e])}};var Qe=(e={})=>{let{wallet:t,createWalletCallbacks:r,recoverWalletCallbacks:n,setWalletRecoveryCallbacks:i}=_react.useContext.call(void 0, f),{onCreateWalletSuccess:o,onCreateWalletError:a,onRecoverWalletError:s,onRecoverWalletSuccess:d,onSetWalletRecoverySuccess:c,onSetWalletRecoveryError:u}=e;return _react.useEffect.call(void 0, ()=>{r.current={onSuccess:o,onError:a}},[o,a]),_react.useEffect.call(void 0, ()=>{n.current={onSuccess:d,onError:s}},[d,s]),_react.useEffect.call(void 0, ()=>{i.current={onSuccess:c,onError:u}},[d,s]),t};var hu=({onStateChange:e})=>{let t=Qe();return _react.useEffect.call(void 0, ()=>{e(t)},[t])};var Su=()=>{let{getIdentityToken:e}=_react.useContext.call(void 0, f);return{getIdentityToken:e}};var Uu=e=>{let{client:t}=_react.useContext.call(void 0, f),r=_react.useCallback.call(void 0, i=>{var a;let o=E(i);return(a=e==null?void 0:e.onError)==null||a.call(e,o),o},[e==null?void 0:e.onError]);return{create:_react.useCallback.call(void 0, ()=>_chunkQTVIWU3Njs.d.call(void 0, void 0,null,function*(){var i;try{if(b())throw new (0, _jssdkcore.PrivyClientError)({code:"attempted_to_create_guest_account_for_logged_in_user",error:"Already logged in, you cannot create a guest account"});let a=W(),s=yield t.auth.guest.create({embedded:a==null?void 0:a.embedded});return(i=e==null?void 0:e.onSuccess)==null||i.call(e,s.user,s.is_new_user),s.user}catch(o){throw r(o)}}),[t,r,e==null?void 0:e.onSuccess])}};function Mu({onMfaRequired:e}){let{client:t}=_react.useContext.call(void 0, f);_react.useEffect.call(void 0, ()=>{function r(){return _chunkQTVIWU3Njs.d.call(void 0, this,null,function*(){var i;let n=b();yield e((i=n==null?void 0:n.mfa_methods.map(({type:o})=>o))!=null?i:[])})}return t.mfaPromises.on("mfaRequired",r),()=>{t.mfaPromises.off("mfaRequired",r)}},[t,e])}var Yn=e=>_chunkQTVIWU3Njs.d.call(void 0, void 0,null,function*(){var n;let r=yield(yield Promise.resolve().then(() => _interopRequireWildcard(require("react-native-passkeys")))).create({rp:e.rp,user:e.user,challenge:e.challenge,pubKeyCredParams:e.pubKeyCredParams,excludeCredentials:e.excludeCredentials,authenticatorSelection:e.authenticatorSelection,timeout:12e4});if(!r)throw new (0, _jssdkcore.PrivyClientError)({code:"failed_to_create_passkey",error:"Could not create passkey"});return _chunkQTVIWU3Njs.b.call(void 0, _chunkQTVIWU3Njs.a.call(void 0, {},r),{type:(n=r.type)!=null?n:"public-key",clientExtensionResults:{}})});var Ze=e=>_chunkQTVIWU3Njs.d.call(void 0, void 0,null,function*(){var n;let r=yield(yield Promise.resolve().then(() => _interopRequireWildcard(require("react-native-passkeys")))).get({rpId:e.rpId,challenge:e.challenge,allowCredentials:e.allowCredentials,timeout:12e4});if(!r)throw new (0, _jssdkcore.PrivyClientError)({code:"no_passkey_found_for_challenge",error:"Could not find a matching passkey to login with"});return _chunkQTVIWU3Njs.b.call(void 0, _chunkQTVIWU3Njs.a.call(void 0, {},r),{type:(n=r.type)!=null?n:"public-key",clientExtensionResults:{}})});function lr(e){var t;return{id:e.id,client_extension_results:{app_id:e.clientExtensionResults.appid,cred_props:e.clientExtensionResults.credProps,hmac_create_secret:e.clientExtensionResults.hmacCreateSecret},raw_id:e.rawId,type:e.type,authenticator_attachment:(t=e.authenticatorAttachment)!=null?t:"platform",response:{authenticator_data:e.response.authenticatorData,client_data_json:e.response.clientDataJSON,signature:e.response.signature,user_handle:e.response.userHandle}}}function ur(e){var t,r,n,i;return{challenge:e.challenge,rpId:e.rp_id,extensions:{appid:(t=e.extensions)==null?void 0:t.app_id,credProps:(r=e.extensions)==null?void 0:r.cred_props,hmacCreateSecret:(n=e.extensions)==null?void 0:n.hmac_create_secret},timeout:e.timeout,allowCredentials:(i=e.allow_credentials)==null?void 0:i.map(({id:o,type:a,transports:s})=>({id:o,type:a,transports:s})),userVerification:e.user_verification}}function $u(e){var t,r,n,i,o,a,s,d;return{rp:e.rp,user:{id:e.user.id,name:e.user.name,displayName:e.user.display_name},challenge:e.challenge,pubKeyCredParams:e.pub_key_cred_params,extensions:{hmacCreateSecret:(t=e.extensions)==null?void 0:t.hmac_create_secret,credProps:(n=(r=e.extensions)==null?void 0:r.cred_props)==null?void 0:n.rk,appid:(i=e.extensions)==null?void 0:i.app_id},attestation:e.attestation,excludeCredentials:e.exclude_credentials,authenticatorSelection:{authenticatorAttachment:(o=e.authenticator_selection)==null?void 0:o.authenticator_attachment,residentKey:(a=e.authenticator_selection)==null?void 0:a.resident_key,userVerification:(s=e.authenticator_selection)==null?void 0:s.user_verification,requireResidentKey:(d=e.authenticator_selection)==null?void 0:d.require_resident_key}}}function tm(){let{client:e}=_react.useContext.call(void 0, f),t=_react.useCallback.call(void 0, o=>_chunkQTVIWU3Njs.d.call(void 0, this,null,function*(){var a,s;switch(o.method){case"sms":yield e.mfa.sms.sendCode({action:"verify"});return;case"passkey":let{options:d}=yield e.mfa.passkey.generateAuthenticationOptions({relying_party:o.relyingParty||((s=(a=W())==null?void 0:a.mfa)==null?void 0:s.relyingParty)});return ur(d);case"totp":return;default:throw new Error(`Unsupported MFA method: ${o.mfaMethod}`)}}),[e]),r=_react.useCallback.call(void 0, o=>_chunkQTVIWU3Njs.d.call(void 0, this,null,function*(){var a,s,d,c,u,m,p;switch(o.method){case"totp":case"sms":if(typeof o.mfaCode!="string")throw new (0, _jssdkcore.PrivyClientError)({code:"invalid_mfa_code",error:"Invalid MFA code"});(d=e.mfaPromises.rootPromise.current)==null||d.resolve({mfaMethod:o.method,mfaCode:o.mfaCode,relyingParty:o.relyingParty||((s=(a=W())==null?void 0:a.mfa)==null?void 0:s.relyingParty)||""}),yield new Promise((y,h)=>{e.mfaPromises.submitPromise.current={resolve:y,reject:h}});break;case"passkey":if(typeof o.mfaCode=="string")throw new (0, _jssdkcore.PrivyClientError)({code:"invalid_passkey_response",error:"Invalid authenticator response"});let w=yield Ze(o.mfaCode),g=lr(w);(m=e.mfaPromises.rootPromise.current)==null||m.resolve({mfaMethod:o.method,relyingParty:o.relyingParty||((u=(c=W())==null?void 0:c.mfa)==null?void 0:u.relyingParty)||"",mfaCode:g}),yield new Promise((y,h)=>{e.mfaPromises.submitPromise.current={resolve:y,reject:h}});break;default:let v=new (0, _jssdkcore.PrivyClientError)({code:"unsupported_mfa_method",error:"Unsupported MFA method"});throw(p=e.mfaPromises.rootPromise.current)==null||p.reject(v),v}}),[e]),n=_react.useCallback.call(void 0, ()=>_chunkQTVIWU3Njs.d.call(void 0, this,null,function*(){let o=b();!o||o.mfa_methods.length===0||(yield e.mfa.verifyMfa())}),[e]),i=_react.useCallback.call(void 0, ()=>{var o;(o=e.mfaPromises.rootPromise.current)==null||o.reject(new (0, _jssdkcore.PrivyClientError)({code:"mfa_canceled",error:"MFA canceled"}))},[e]);return{init:t,submit:r,prompt:n,cancel:i}}function am(){let{client:e}=_react.useContext.call(void 0, f),t=_react.useCallback.call(void 0, i=>_chunkQTVIWU3Njs.d.call(void 0, this,null,function*(){switch(i.method){case"sms":case"totp":return yield e.mfa.initEnrollMfa(i);case"passkey":return;default:throw new Error(`Unsupported MFA method: ${i.method}`)}}),[e]),r=_react.useCallback.call(void 0, i=>_chunkQTVIWU3Njs.d.call(void 0, this,null,function*(){switch(i.method){case"sms":case"totp":case"passkey":yield e.mfa.submitEnrollMfa(i);return;default:throw new Error(`Unsupported MFA method: ${i.method}`)}}),[e]),n=_react.useCallback.call(void 0, i=>_chunkQTVIWU3Njs.d.call(void 0, this,null,function*(){switch(i.method){case"sms":case"totp":yield e.mfa.unenrollMfa(i.method);return;case"passkey":yield e.mfa.submitEnrollMfa({method:"passkey",credentialIds:[],removeForLogin:i.removeForLogin});return;default:throw new Error(`Unsupported MFA method: ${i.method}`)}}),[e]);return{initMfaEnrollment:t,submitMfaEnrollment:r,unenrollMfa:n}}var oi=()=>{let e=U(),t=O(),r=_react.useMemo.call(void 0, ()=>{let o=_jssdkcore.getAllUserEmbeddedEthereumWallets.call(void 0, e).map(a=>{let s=_jssdkcore.getEntropyDetailsFromUser.call(void 0, e,a);return s?{account:a,entropy:s}:null});return o.some(a=>a===null)?[]:o.filter(a=>a!==null).map(({account:a,entropy:{entropyId:s,entropyIdVerifier:d}})=>({address:a.address,walletIndex:a.wallet_index,chainType:a.chain_type,getProvider:()=>t.embeddedWallet.getEthereumProvider({wallet:a,entropyId:s,entropyIdVerifier:d,onNeedsRecovery:c=>_chunkQTVIWU3Njs.d.call(void 0, void 0,null,function*(){var u;yield(u=fe())==null?void 0:u(c)})})}))},[t,e]),n=_react.useCallback.call(void 0, (...o)=>_chunkQTVIWU3Njs.d.call(void 0, void 0,[...o],function*({createAdditional:i=!1}={}){let{user:a}=yield t.user.get(),s=_jssdkcore.getAllUserEmbeddedEthereumWallets.call(void 0, a);if(!i&&s.length>0)throw new (0, _jssdkcore.PrivyClientError)({code:"embedded_wallet_creation_error",error:"Wallet already exists for this user. Set `createAdditional` to `true` to create another wallet"});let d=_jssdkcore.getEntropyDetailsFromUser.call(void 0, a);if(!d){let g=yield t.embeddedWallet.create({});return tt(g.user,0),{user:g.user}}let{entropyId:c,entropyIdVerifier:u}=d;if(u==="solana-address-verifier"){let g=_jssdkcore.getUserEmbeddedSolanaWallet.call(void 0, a),v=yield t.embeddedWallet.create({solanaAccount:g});return tt(v.user,0),{user:v.user}}let p=s.map(g=>g.wallet_index).reduce((g,v)=>Math.max(g,v),0)+1,w=yield t.embeddedWallet.add({chainType:"ethereum",hdWalletIndex:p,entropyId:c,entropyIdVerifier:u});return tt(w.user,p),{user:w.user}}),[t]);return _react.useMemo.call(void 0, ()=>({wallets:r,create:n}),[r,n])};function tt(e,t){let r=_jssdkcore.getAllUserEmbeddedEthereumWallets.call(void 0, e).find(n=>n.wallet_index===t);if(!e||!r)throw new (0, _jssdkcore.PrivyClientError)({code:"embedded_wallet_creation_error",error:"Unknown error creating wallet"})}var ii=(e={})=>{let{solanaWallet:t,createSolanaWalletCallbacks:r,recoverSolanaWalletCallbacks:n}=_react.useContext.call(void 0, f),{onCreateWalletSuccess:i,onCreateWalletError:o,onRecoverWalletError:a,onRecoverWalletSuccess:s}=e;return _react.useEffect.call(void 0, ()=>{r.current={onSuccess:i,onError:o}},[i,o]),_react.useEffect.call(void 0, ()=>{n.current={onSuccess:s,onError:a}},[s,a]),t};var di=()=>{let e=U(),t=O(),r=_react.useMemo.call(void 0, ()=>{let i=_jssdkcore.getEntropyDetailsFromUser.call(void 0, e);if(!i)return[];let o=_jssdkcore.getAllUserEmbeddedBitcoinWallets.call(void 0, e),{entropyId:a,entropyIdVerifier:s}=i;return o.map(d=>({address:d.address,walletIndex:d.wallet_index,publicKey:d.public_key,chainType:d.chain_type,getProvider:()=>_jssdkcore.isUnifiedWallet.call(void 0, d)?Promise.reject(new (0, _jssdkcore.PrivyClientError)({code:"unsupported_wallet_type",error:"Bitcoin wallet providers are only supported for on-device execution and this app uses TEE execution. Use the useSignRawHash hook from @privy-io/expo/extended-chains to sign over a hash with this wallet. Learn more at https://docs.privy.io/recipes/tee-wallet-migration-guide"})):t.embeddedWallet.getBitcoinProvider({wallet:d,entropyId:a,entropyIdVerifier:s})}))},[t,e]),n=_react.useCallback.call(void 0, a=>_chunkQTVIWU3Njs.d.call(void 0, void 0,[a],function*({chainType:i,createAdditional:o=!1}){var y;let s=t.app.getConfig();if(((y=s==null?void 0:s.embedded_wallet_config)==null?void 0:y.mode)==="user-controlled-server-wallets-only")throw i==="bitcoin-segwit"?new (0, _jssdkcore.PrivyClientError)({code:"unsupported_wallet_type",error:"This app uses TEE execution. Use the useCreateWallet hook from @privy-io/expo/extended-chains to create the wallet instead. Learn more https://docs.privy.io/recipes/tee-wallet-migration-guide"}):new (0, _jssdkcore.PrivyClientError)({code:"unsupported_wallet_type",error:`Bitcoin (${i}) wallets are only supported for on-device execution and this app uses TEE execution. Learn more https://docs.privy.io/recipes/tee-wallet-migration-guide`});let{user:d}=yield t.user.get(),c=_jssdkcore.getEntropyDetailsFromUser.call(void 0, d);if(!c)throw new (0, _jssdkcore.PrivyClientError)({code:"embedded_wallet_creation_error",error:"No existing wallet for this user, create an Ethereum walet first to add a Bitcoin wallet"});let{entropyId:u,entropyIdVerifier:m}=c,p=_jssdkcore.getAllUserEmbeddedBitcoinWallets.call(void 0, d).filter(h=>h.chain_type===i);if(!o&&p.length>0)throw new (0, _jssdkcore.PrivyClientError)({code:"embedded_wallet_creation_error",error:"Wallet already exists for this user. Set `createAdditional` to `true` to create another wallet"});let w=p.length===0?0:Math.max(...p.map(h=>h.wallet_index),0)+1,g=yield t.embeddedWallet.add({chainType:i,hdWalletIndex:w,entropyId:u,entropyIdVerifier:m}),v=_jssdkcore.getAllUserEmbeddedBitcoinWallets.call(void 0, g.user).find(h=>h.chain_type===i&&h.wallet_index===w);if(!g.user||!v)throw new (0, _jssdkcore.PrivyClientError)({code:"embedded_wallet_creation_error",error:"Unknown error creating wallet"});return{user:g.user,provider:yield t.embeddedWallet.getBitcoinProvider({wallet:v,entropyId:u,entropyIdVerifier:m})}}),[t]);return{wallets:r,create:n}};var nt=()=>{let{isReady:e,logout:t,getAccessToken:r,error:n}=_react.useContext.call(void 0, f);return{user:U(),isReady:e,error:n,logout:t,getAccessToken:r}};var pi=()=>{let e=O();return _react.useMemo.call(void 0, ()=>({generateAuthorizationSignature(r){return _chunkQTVIWU3Njs.d.call(void 0, this,null,function*(){let{signature:n}=yield _jssdkcore.generateAuthorizationSignature.call(void 0, (...i)=>e.embeddedWallet.signWithUserSigner(...i),r);return{signature:n}})}}),[e])};function hr(e,t){return _chunkQTVIWU3Njs.d.call(void 0, this,null,function*(){var i;let r=(i=_jssdkcore.getUserEmbeddedEthereumWallet.call(void 0, t))!=null?i:_jssdkcore.getUserEmbeddedSolanaWallet.call(void 0, t);if(!r||_jssdkcore.isUnifiedWallet.call(void 0, r))return{success:!0,migrated:!1};if(r.imported)throw new Error("Imported wallets cannot be migrated");if(_jssdkcore.getAllUserEmbeddedBitcoinWallets.call(void 0, t).length>0)throw new Error("Bitcoin wallets cannot be migrated");let n=t.linked_accounts.filter(_jssdkcore.isEmbeddedWalletAccount).filter(o=>!o.imported).filter(o=>o.chain_type==="ethereum"||o.chain_type==="solana");return r.chain_type==="ethereum"?yield e.embeddedWallet.getProvider(r):r.chain_type==="solana"&&(yield e.embeddedWallet.getSolanaProvider(r,r.address,"solana-address-verifier")),yield e.embeddedWallet.delegateWallets({rootWallet:{address:r.address,chainType:r.chain_type,imported:r.imported},delegatedWallets:n.map(o=>({address:o.address,chainType:o.chain_type,walletIndex:o.wallet_index}))}),yield e.user.get(),{success:!0,migrated:!0}})}var wr=()=>{let e=O();return{migrate:_react.useCallback.call(void 0, ()=>_chunkQTVIWU3Njs.d.call(void 0, void 0,null,function*(){var o;let r=b(),n=e.app.getConfig();if(((o=n==null?void 0:n.embedded_wallet_config)==null?void 0:o.mode)!=="user-controlled-server-wallets-only")return{success:!0};if(!r)throw new (0, _jssdkcore.PrivyClientError)({code:"embedded_wallet_before_logged_in",error:"User must be authenticated before migrating wallets"});return hr(e,r)}),[e])}};var vr=({disabled:e})=>{let{migrate:t}=wr(),{user:r}=nt(),n=_react.useRef.call(void 0, !1);return _react.useEffect.call(void 0, ()=>{e||r&&(n.current||(n.current=!0,t().then(i=>{i.migrated&&!n.current&&(console.info("Migrated wallets for user"),n.current=!0)}).catch(i=>{console.debug("Unable to migrate wallets: ",i)}).finally(()=>{n.current=!1})))},[t,r,e]),null};var f=_react.createContext.call(void 0, null),ee;function $p(e){return ee?ee.getAccessToken():e!=null&&e.strict?Promise.reject(new (0, _jssdkcore.PrivyClientError)({code:"attempted_to_read_storage_before_client_initialized",error:"Called `getAccessToken` before client initialized"})):(console.warn("Called `getAccessToken` before client initialized"),Promise.resolve(null))}var Yp=e=>{var ct,dt,lt;xi();let[t,r]=_react.useState.call(void 0, _reactnative.AppState.currentState==="active");_react.useEffect.call(void 0, ()=>{let I=_reactnative.AppState.addEventListener("change",Ar=>{r(Ar==="active")});return()=>{I.remove()}},[]),_react.useEffect.call(void 0, ()=>gt(e.config),[e.config]);let[n,i]=_react.useState.call(void 0, !1),[o,a]=_react.useState.call(void 0, null),[s,d]=_react.useState.call(void 0, !1),[c,u]=_react.useState.call(void 0, {status:"disconnected",account:null}),[m,p]=_react.useState.call(void 0, {status:"disconnected"}),[w,g]=_react.useState.call(void 0, {status:"initial"}),[v,y]=_react.useState.call(void 0, {status:"initial"}),[h,S]=_react.useState.call(void 0, {status:"initial"}),[_,C]=_react.useState.call(void 0, {status:"initial"}),[k,x]=_react.useState.call(void 0, {status:"initial"}),[M,ue]=_react.useState.call(void 0, {status:"initial"}),[me,Ae]=_react.useState.call(void 0, {status:"initial"}),te=_react.useRef.call(void 0, {}),Re=_react.useRef.call(void 0, {}),Ie=_react.useRef.call(void 0, {}),at=_react.useRef.call(void 0, {}),st=_react.useRef.call(void 0, {}),pe=_react.useCallback.call(void 0, I=>{if(I){Me(I),a(null);return}Me(null),g({status:"initial"}),y({status:"initial"}),u({status:"disconnected",account:null})},[]),R=_react.useMemo.call(void 0, ()=>{let I=e.storage||_chunkQTVIWU3Njs.g;return e.client?ee=e.client:ee=ft({appId:e.appId,clientId:e.clientId,supportedChains:e.supportedChains,storage:I,baseUrl:e.baseUrl,logLevel:e.logLevel}),ee.setCallbacks({setUser:pe,setIsReady:d}),ee},[e.client,e.storage,e.appId,e.clientId,e.baseUrl,e.supportedChains,e.logLevel,pe]),_r=_react.useCallback.call(void 0, ()=>{let I=b();return pe(null),R.auth.logout(I?{userId:I==null?void 0:I.id}:void 0)},[pe,R]),Cr=_react.useCallback.call(void 0, ()=>_chunkQTVIWU3Njs.d.call(void 0, void 0,null,function*(){try{return yield R.getAccessToken()}catch(I){return console.debug(I),null}}),[R]),kr=_react.useCallback.call(void 0, ()=>R.getIdentityToken(),[R]);Tt({client:R,isUserInitialized:n,setIsUserInitialized:i,setError:a});let Wr=Ot({client:R,appId:e.appId,createWalletCallbacks:te,recoverWalletCallbacks:Re,setWalletRecoveryCallbacks:Ie,setRecoveryFlowState:S,wallet:c,setWallet:u}),xr=kt({client:R,createSolanaWalletCallbacks:at,recoverSolanaWalletCallbacks:st,setSolanaRecoveryFlowState:C,solanaWallet:m,setSolanaWallet:p});Ft({client:R,createWalletCallbacks:te,recoverWalletCallbacks:Re,setWalletRecoveryCallbacks:Ie,recoveryFlowState:h,oAuthState:v,setRecoveryFlowState:S,setWallet:u,appStateVisible:t});let{customAuthStateIsSettled:Pr}=Mt({client:R,isReady:n}),Ur=V();return _react2.default.createElement(_react2.default.Fragment,null,_react2.default.createElement(f.Provider,{value:{client:R,isReady:Ur&&n&&Pr,error:o,logout:_r,getAccessToken:Cr,getIdentityToken:kr,wallet:_chunkQTVIWU3Njs.a.call(void 0, _chunkQTVIWU3Njs.a.call(void 0, {},c),Wr),solanaWallet:_chunkQTVIWU3Njs.a.call(void 0, _chunkQTVIWU3Njs.a.call(void 0, {},m),xr),oAuthState:v,recoveryFlowState:h,setRecoveryFlowState:S,solanaRecoveryFlowState:_,setSolanaRecoveryFlowState:C,createWalletCallbacks:te,recoverWalletCallbacks:Re,setWalletRecoveryCallbacks:Ie,createSolanaWalletCallbacks:at,recoverSolanaWalletCallbacks:st,setOAuthState:y,siweState:k,setSiweState:x,otpState:w,setOtpState:g,passkeyState:M,setPasskeyState:ue,farcasterState:me,setFarcasterState:Ae}},e.children,_react2.default.createElement(vr,{disabled:(lt=(dt=(ct=e.config)==null?void 0:ct.embedded)==null?void 0:dt.disableAutomaticMigration)!=null?lt:!1})),_react2.default.createElement(_reactnative.View,{style:{width:0,height:0,overflow:"hidden"}},_react2.default.createElement(vt,{client:R,isClientReady:s})))},xi=()=>{if(_react.useContext.call(void 0, f))throw new (0, _jssdkcore.PrivyClientError)({code:"configuration_error",error:"Found multiple instances of PrivyProvider, ensure there is only one mounted in your application tree."})};var ny=e=>{let{client:t,setSiweState:r,siweState:n}=_react.useContext.call(void 0, f),i=_react.useCallback.call(void 0, s=>{var c;let d=E(s);return r({status:"error",error:d}),(c=e==null?void 0:e.onError)==null||c.call(e,d),d},[e==null?void 0:e.onError]),o=_react.useCallback.call(void 0, u=>_chunkQTVIWU3Njs.d.call(void 0, void 0,[u],function*({wallet:s,from:{domain:d,uri:c}}){var m;try{r({status:"generating-message"});let p=yield t.auth.siwe.init(s,d,c);return r({status:"awaiting-signature"}),(m=e==null?void 0:e.onGenerateMessage)==null||m.call(e,p.message),p.message}catch(p){throw i(p)}}),[t,i,e==null?void 0:e.onGenerateMessage]),a=_react.useCallback.call(void 0, c=>_chunkQTVIWU3Njs.d.call(void 0, void 0,[c],function*({signature:s,messageOverride:d}){var u;try{if(!b())throw new (0, _jssdkcore.PrivyClientError)({code:"attempted_link_siwe_before_logged_in",error:"Must be logged in to link a wallet, Use `useLoginWithSiwe` to login with a wallet"});r({status:"submitting-signature"});let{user:p}=yield t.auth.siwe.linkWithSiwe(s,void 0,d);return r({status:"done"}),(u=e==null?void 0:e.onSuccess)==null||u.call(e,p),p}catch(m){throw i(m)}}),[t,i,e==null?void 0:e.onSuccess]);return{generateSiweMessage:o,linkWithSiwe:a,state:n}};exports.a = W; exports.b = b; exports.c = qi; exports.d = U; exports.e = Gi; exports.f = Or; exports.g = E; exports.h = G; exports.i = ft; exports.j = ny; exports.k = Is; exports.l = O; exports.m = Bs; exports.n = Xs; exports.o = ac; exports.p = yc; exports.q = bc; exports.r = Uc; exports.s = Tc; exports.t = qc; exports.u = ed; exports.v = ad; exports.w = fd; exports.x = kd; exports.y = Rd; exports.z = jd; exports.A = qd; exports.B = Xd; exports.C = il; exports.D = gl; exports.E = Cl; exports.F = Il; exports.G = Dl; exports.H = ql; exports.I = eu; exports.J = du; exports.K = Qe; exports.L = hu; exports.M = Su; exports.N = Uu; exports.O = Mu; exports.P = Yn; exports.Q = Ze; exports.R = $u; exports.S = tm; exports.T = am; exports.U = oi; exports.V = ii; exports.W = di; exports.X = nt; exports.Y = pi; exports.Z = wr; exports._ = f; exports.$ = $p; exports.aa = Yp;
