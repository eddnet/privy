"use strict";Object.defineProperty(exports, "__esModule", {value: true}); function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { newObj[key] = obj[key]; } } } newObj.default = obj; return newObj; } } function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }var _chunkQTVIWU3Njs = require('./chunk-QTVIWU3N.js');var _base = require('@scure/base');var _expolinking = require('expo-linking'); var c = _interopRequireWildcard(_expolinking);var _react = require('react');var _tweetnacl = require('tweetnacl'); var _tweetnacl2 = _interopRequireDefault(_tweetnacl);var _zustand = require('zustand');var E=_chunkQTVIWU3Njs.f.call(void 0, _chunkQTVIWU3Njs.g),v=(t,i,s)=>`${t}/ul/v1/${i}?${s.toString()}`,U=(t,i)=>{if(!i)throw new Error("missing shared secret");let s=_tweetnacl2.default.randomBytes(24),h=_tweetnacl2.default.box.after(Buffer.from(JSON.stringify(t)),s,i);return{nonce:_base.base58.encode(s),data:_base.base58.encode(h)}},K=(t,i,s)=>{if(!s)throw new Error("missing shared secret");let h=_tweetnacl2.default.box.open.after(_base.base58.decode(t),_base.base58.decode(i),s);if(!h)throw new Error("Unable to decrypt data");return JSON.parse(Buffer.from(h).toString("utf8"))},ne=t=>JSON.stringify({publicKey:Array.from(t.publicKey),secretKey:Array.from(t.secretKey)}),re=t=>{let i=JSON.parse(t);return{publicKey:new Uint8Array(i.publicKey),secretKey:new Uint8Array(i.secretKey)}},z="wallet_keypair",x=6e4,W= exports.useDeeplinkWalletConnector =({baseUrl:t,appUrl:i,redirectUri:s="/",autoReconnect:h=!0,encryptionPublicKeyName:l})=>{if(!t||!i||!s||!l)throw new Error("baseUrl, appUrl, redirectUri, and encryptionPublicKeyName are required");let{connection:p,setConnection:b,isConnected:P,sharedSecretRef:w}=te({baseUrl:t,autoReconnect:h}),e=_react.useRef.call(void 0, null),$=_react.useCallback.call(void 0, a=>_chunkQTVIWU3Njs.d.call(void 0, void 0,null,function*(){var f;if(!a)return;let n=new URL(a).searchParams,d=n.get("wallet_id");if(!d||d!==l)return;if(n.get("errorCode")){let r=Object.fromEntries([...n]),g=(f=r==null?void 0:r.errorMessage)!=null?f:JSON.stringify(Object.fromEntries([...n]),null,2);console.error("Error from wallet provider: ",g);return}switch(n.get("wallet_action")){case"onConnect":try{if(!n.get("data")||!n.get("nonce")||!n.get(l))throw console.error("missing required fields in response"),new Error("missing required fields in response");let r=yield L(),g=_tweetnacl2.default.box.before(_base.base58.decode(n.get(l)),r.secretKey),y=K(n.get("data"),n.get("nonce"),g);w.current=g,b(y),yield E.put(`${t}-key`,_base.base64.encode(g)),yield E.put(`${t}-data`,JSON.stringify(y))}catch(r){console.error("Failed to process connect response:",r)}break;case"onSignMessage":try{if(!e.current||e.current.type!=="signMessage"){console.warn("Received signature response but no pending signature request");return}if(!n.get("data")||!n.get("nonce"))throw console.error("missing required fields in response"),new Error("missing required fields in response");let r=K(n.get("data"),n.get("nonce"),w.current);e.current.resolve(r),e.current=null}catch(r){console.error("Failed to process signature response:",r),e.current&&(e.current.reject(r),e.current=null)}break;case"onSignTransaction":try{if(!e.current||e.current.type!=="signTransaction"){console.warn("Received signature response but no pending signature request");return}if(!n.get("data")||!n.get("nonce"))throw console.error("missing required fields in response"),new Error("missing required fields in response");let r=K(n.get("data"),n.get("nonce"),w.current);e.current.resolve(r),e.current=null}catch(r){console.error("Failed to process transaction response:",r),e.current&&(e.current.reject(r),e.current=null)}break;case"onSignAndSendTransaction":try{if(!e.current||e.current.type!=="signAndSendTransaction"){console.warn("Received signature response but no pending signature request");return}if(!n.get("data")||!n.get("nonce"))throw console.error("missing required fields in response"),new Error("missing required fields in response");let r=K(n.get("data"),n.get("nonce"),w.current);e.current.resolve(r),e.current=null}catch(r){console.error("Failed to process transaction response:",r),e.current&&(e.current.reject(r),e.current=null)}break;case"onSignAllTransactions":try{if(!e.current||e.current.type!=="signAllTransactions"){console.warn("Received signature response but no pending signature request");return}if(!n.get("data")||!n.get("nonce"))throw console.error("missing required fields in response"),new Error("missing required fields in response");let r=K(n.get("data"),n.get("nonce"),w.current);e.current.resolve(r),e.current=null}catch(r){console.error("Failed to process transaction response:",r),e.current&&(e.current.reject(r),e.current=null)}break;case"onDisconnect":b(null);break}}),[t,l,b,w]);_react.useEffect.call(void 0, ()=>{(()=>_chunkQTVIWU3Njs.d.call(void 0, void 0,null,function*(){let n=yield c.getInitialURL();n&&$(n)}))();let o=c.addEventListener("url",({url:n})=>$(n).catch(d=>{e.current&&(e.current.reject(d),e.current=null)}));return()=>{o.remove()}},[l,$]);let I=()=>_chunkQTVIWU3Njs.d.call(void 0, void 0,null,function*(){try{let a=yield L();if(!a)throw new Error("No dapp key pair found");let o={session:p==null?void 0:p.session},{nonce:n,data:d}=U(o,w.current),S=new URLSearchParams({nonce:n,dapp_encryption_public_key:_base.base58.encode(a.publicKey),redirect_link:`${c.createURL(s)}?wallet_action=onDisconnect&wallet_id=${l}`,payload:d}),f=v(t,"disconnect",S);yield c.openURL(f)}catch(a){throw console.error("Failed to disconnect:",a),a}}),Y=a=>_chunkQTVIWU3Njs.d.call(void 0, void 0,null,function*(){if(!P||!p)throw new Error("Wallet not connected");try{let o=yield L();if(!o)throw new Error("No dapp key pair found");let n={session:p.session,message:_base.base58.encode(Buffer.from(a)),display:"utf8"},{nonce:d,data:S}=U(n,w.current),f=new URLSearchParams({dapp_encryption_public_key:_base.base58.encode(o.publicKey),nonce:d,payload:S,redirect_link:`${c.createURL(s)}?wallet_action=onSignMessage&wallet_id=${l}`}),r=v(t,"signMessage",f);return new Promise((g,y)=>{c.openURL(r);let T=setTimeout(()=>{e.current&&(y(new Error("Signature request timed out")),e.current=null)},x),k=R=>{clearTimeout(T),g(R)},A=R=>{clearTimeout(T),y(R)};e.current={type:"signMessage",payload:a,resolve:k,reject:A}})}catch(o){throw e.current=null,console.error("Failed to sign message:",o),o}}),G=(a,o)=>_chunkQTVIWU3Njs.d.call(void 0, void 0,null,function*(){if(!P||!p)throw new Error("Wallet not connected");try{let n=yield L();if(!n)throw new Error("No dapp key pair found");let d=a.serialize({requireAllSignatures:!1}),S={session:p.session,transaction:_base.base58.encode(d),sendOptions:o},{nonce:f,data:r}=U(S,w.current),g=new URLSearchParams({nonce:f,dapp_encryption_public_key:_base.base58.encode(n.publicKey),redirect_link:`${c.createURL(s)}?wallet_action=onSignAndSendTransaction&wallet_id=${l}`,payload:r}),y=v(t,"signAndSendTransaction",g);return new Promise((T,k)=>{c.openURL(y);let A=setTimeout(()=>{e.current&&(k(new Error("Signature request timed out")),e.current=null)},x),R=O=>{clearTimeout(A),T(O)},_=O=>{clearTimeout(A),k(O)};e.current={type:"signAndSendTransaction",payload:a,resolve:R,reject:_}})}catch(n){throw e.current=null,console.error("Failed to sign and send transaction:",n),n}}),H=a=>_chunkQTVIWU3Njs.d.call(void 0, void 0,null,function*(){if(!P||!p)throw new Error("Wallet not connected");try{let o=yield L();if(!o)throw new Error("No dapp key pair found");let d={transactions:a.map(y=>_base.base58.encode(y.serialize({requireAllSignatures:!1}))),session:p.session},{nonce:S,data:f}=U(d,w.current),r=new URLSearchParams({nonce:S,dapp_encryption_public_key:_base.base58.encode(o.publicKey),redirect_link:`${c.createURL(s)}?wallet_action=onSignAllTransactions&wallet_id=${l}`,payload:f}),g=v(t,"signAllTransactions",r);return new Promise((y,T)=>{c.openURL(g);let k=setTimeout(()=>{e.current&&(T(new Error("Signature request timed out")),e.current=null)},x),A=_=>{clearTimeout(k),y(_)},R=_=>{clearTimeout(k),T(_)};e.current={type:"signAllTransactions",payload:a,resolve:A,reject:R}})}catch(o){throw e.current=null,console.error("Failed to sign all transactions:",o),o}}),Q=a=>_chunkQTVIWU3Njs.d.call(void 0, void 0,null,function*(){if(!P||!p)throw new Error("Wallet not connected");try{let o=yield L();if(!o)throw new Error("No dapp key pair found");let n=a.serialize({requireAllSignatures:!1}),d={session:p.session,transaction:_base.base58.encode(n)},{nonce:S,data:f}=U(d,w.current),r=new URLSearchParams({nonce:S,dapp_encryption_public_key:_base.base58.encode(o.publicKey),redirect_link:`${c.createURL(s)}?wallet_action=onSignTransaction&wallet_id=${l}`,payload:f}),g=v(t,"signTransaction",r);return new Promise((y,T)=>{c.openURL(g);let k=setTimeout(()=>{e.current&&(T(new Error("Signature request timed out")),e.current=null)},x),A=_=>{clearTimeout(k),y(_)},R=_=>{clearTimeout(k),T(_)};e.current={type:"signTransaction",payload:a,resolve:A,reject:R}})}catch(o){throw e.current=null,console.error("Failed to sign transaction:",o),o}}),V=()=>_chunkQTVIWU3Njs.d.call(void 0, void 0,null,function*(){let a=yield L();if(!a)throw new Error("No dapp key pair found");try{let o=new URLSearchParams({dapp_encryption_public_key:_base.base58.encode(a.publicKey),app_url:i,redirect_link:`${c.createURL(s)}?wallet_action=onConnect&wallet_id=${l}`}),n=v(t,"connect",o);yield c.openURL(n)}catch(o){console.error("Failed to open wallet connection:",o)}});return{address:p==null?void 0:p.public_key,connect:V,signMessage:Y,signTransaction:Q,signAndSendTransaction:G,signAllTransactions:H,disconnect:I,isConnected:P}},te=({autoReconnect:t,baseUrl:i})=>{let[s,h]=_react.useState.call(void 0, null),l=_react.useRef.call(void 0, null);return _react.useEffect.call(void 0, ()=>{let p=()=>_chunkQTVIWU3Njs.d.call(void 0, void 0,null,function*(){let b=yield E.get(`${i}-key`),P=yield E.get(`${i}-data`);b&&P&&(l.current=_base.base64.decode(b),h(JSON.parse(P)))});t&&!l.current&&p().catch(console.warn)},[t,i]),{connection:s,setConnection:h,isConnected:!!s,sharedSecretRef:l}},j=_zustand.createStore.call(void 0, ()=>({dappKeyPair:null})),L=()=>_chunkQTVIWU3Njs.d.call(void 0, void 0,null,function*(){let t=j.getState().dappKeyPair;if(t)return t;try{let i=yield E.get(z);if(i&&typeof i=="string"){let s=re(i);return j.setState({dappKeyPair:s}),s}else{let s=_tweetnacl2.default.box.keyPair();return j.setState({dappKeyPair:s}),yield E.put(z,ne(s)),s}}catch(i){throw console.error("Failed to initialize key pair:",i),i}});var de=t=>W(_chunkQTVIWU3Njs.b.call(void 0, _chunkQTVIWU3Njs.a.call(void 0, {},t),{baseUrl:"https://phantom.app",encryptionPublicKeyName:"phantom_encryption_public_key"}));var we=t=>W(_chunkQTVIWU3Njs.b.call(void 0, _chunkQTVIWU3Njs.a.call(void 0, {},t),{baseUrl:"https://backpack.app",encryptionPublicKeyName:"wallet_encryption_public_key"}));exports.useBackpackDeeplinkWalletConnector = we; exports.useDeeplinkWalletConnector = W; exports.usePhantomDeeplinkWalletConnector = de;
