import { User, LinkedAccount, LinkedAccountEmbeddedWallet, LinkedAccountEthereumEmbeddedWallet, LinkedAccountSolanaEmbeddedWallet, LinkedAccountBitcoinSegwitEmbeddedWallet, LinkedAccountBitcoinTaprootEmbeddedWallet, LinkedAccountSmartWallet, LinkedAccountEmail, LinkedAccountPhone, LinkedAccountEthereum, LinkedAccountSolana, LinkedAccountGoogleOAuth, LinkedAccountTwitterOAuth, LinkedAccountDiscordOAuth, LinkedAccountGitHubOAuth, LinkedAccountSpotifyOAuth, LinkedAccountInstagramOAuth, LinkedAccountTiktokOAuth, LinkedAccountLinkedInOAuth, LinkedAccountAppleOAuth, LinkedAccountCustomJwt, LinkedAccountFarcaster, LinkedAccountPasskey, LinkedAccountTelegram, LinkedAccountCrossApp } from '@privy-io/api-types';
import { PrivyClientError, PrivyApiError, PrivyEmbeddedWalletProvider, PrivyEmbeddedSolanaWalletProvider, ExternalWallet } from '@privy-io/js-sdk-core';

type PrivySuccessObject = {
    success: boolean;
};
type OtpFlowState = {
    status: 'initial';
} | {
    status: 'error';
    error: Error | null;
} | {
    status: 'sending-code';
} | {
    status: 'awaiting-code-input';
} | {
    status: 'submitting-code';
} | {
    status: 'done';
};
type AuthSuccessCallback = (user: User, isNewUser?: boolean) => void;
type AuthLinkSuccessCallback = (user: User) => void;
type ErrorCallback = (error: PrivyClientError | PrivyApiError | Error) => void;
type OtpLoginHookOptions<AuthSourceArgs> = {
    onError?: ErrorCallback;
    onSendCodeSuccess?: (args: AuthSourceArgs) => void;
    onLoginSuccess?: AuthSuccessCallback;
};
type OtpLinkHookOptions<AuthSourceArgs> = {
    onError?: ErrorCallback;
    onSendCodeSuccess?: (args: AuthSourceArgs) => void;
    onLinkSuccess?: AuthLinkSuccessCallback;
};
type OtpLinkHookResult<SendArgs, LinkArgs> = {
    sendCode: (args: SendArgs) => Promise<PrivySuccessObject>;
    linkWithCode: (args: LinkArgs) => Promise<User | undefined>;
    state: OtpFlowState;
};
type OtpLoginHookResult<SendArgs, LoginArgs> = {
    sendCode: (args: SendArgs) => Promise<PrivySuccessObject>;
    loginWithCode: (args: LoginArgs) => Promise<User | undefined>;
    state: OtpFlowState;
};
type WalletRecoveryCallbacks = {
    onError?: ErrorCallback;
    onSuccess?: (provider: PrivyEmbeddedWalletProvider) => void;
};
type SolanaWalletRecoveryCallbacks = {
    onError?: ErrorCallback;
    onSuccess?: (provider: PrivyEmbeddedSolanaWalletProvider) => void;
};
type SiweFlowState = {
    status: 'initial';
} | {
    status: 'error';
    error: Error | null;
} | {
    status: 'generating-message';
} | {
    status: 'awaiting-signature';
} | {
    status: 'submitting-signature';
} | {
    status: 'done';
};
/** [EIP-4361](https://eips.ethereum.org/EIPS/eip-4361) message to be used in signing */
type GenerateSiweMessageResponse = Promise<string>;
type GenerateSiweMessage = (opts: {
    /** Wallet to request a [Sign-In With Ethereum](https://eips.ethereum.org/EIPS/eip-4361) signature from */
    wallet: ExternalWallet;
    /**
     * Required fields that describe origin of [Sign-In With Ethereum](https://eips.ethereum.org/EIPS/eip-4361) signature request
     */
    from: {
        /** [RFC 3986](https://datatracker.ietf.org/doc/html/rfc3986) authority that is requesting the signing */
        domain: string;
        /** [RFC 3986](https://datatracker.ietf.org/doc/html/rfc3986) URI referring to the resource that is the subject of the signing */
        uri: string;
    };
}) => GenerateSiweMessageResponse;
type FarcasterFlowState = {
    status: 'initial';
} | {
    status: 'error';
    error: Error | null;
} | {
    status: 'generating-uri';
} | {
    status: 'awaiting-uri';
} | {
    status: 'polling-status';
} | {
    status: 'submitting-token';
} | {
    status: 'done';
};
type LoginWithFarcasterInput = {
    relyingParty?: string;
    /**
     * The URL path to redirect to after the Farcaster flow is complete.
     *
     * NOTE: This URL should be a deep link path that will open the app and handle the redirect. If
     * not provided it will default to the root path `/`.
     */
    redirectUrl?: string;
    disableSignup?: boolean;
};
type LinkFarcasterInput = {
    relyingParty?: string;
    /**
     * The URL path to redirect to after the Farcaster flow is complete.
     *
     * NOTE: This URL should be a deep link path that will open the app and handle the redirect. If
     * not provided it will default to the root path `/`.
     */
    redirectUrl?: string;
};
type SubmitFarcasterOptions = {
    pollIntervalMs: number;
    pollAttempts: number;
};
type PasskeyFlowState = {
    status: 'initial';
} | {
    status: 'error';
    error: Error | null;
} | {
    status: 'generating-challenege';
} | {
    status: 'awaiting-passkey';
} | {
    status: 'submitting-response';
} | {
    status: 'done';
};
type SubmitPasskeyInput = {
    /**
     * The URL associated with this app. See: https://w3c.github.io/webauthn/#relying-party
     *
     * It will be used by the operating system to verify the app association.
     * - On iOS via [apple-app-site-association](https://developer.apple.com/documentation/xcode/supporting-associated-domains)
     * - On Android via [assetlinks](https://developers.google.com/digital-asset-links/v1/getting-started)
     */
    relyingParty: string;
};
type SubmitPasskeySignature = (input: SubmitPasskeyInput) => Promise<User | undefined>;
type PasskeyLoginHookOptions = {
    onError?: ErrorCallback;
    onSuccess?: AuthSuccessCallback;
};
type PasskeyLinkHookOptions = {
    onError?: ErrorCallback;
    onSuccess?: AuthLinkSuccessCallback;
};
type PasskeyHookResult<T extends 'login' | 'link'> = {
    state: PasskeyFlowState;
} & (T extends 'login' ? {
    loginWithPasskey: SubmitPasskeySignature;
} : {
    linkWithPasskey: SubmitPasskeySignature;
});

/** @deprecated use the {@link User} type instead. */
type PrivyUser = User;
/** @deprecated use the {@link LinkedAccount} type instead. */
type PrivyLinkedAccount = LinkedAccount;
/** @deprecated use the {@link LinkedAccount} type instead */
type LinkedAccountWithMetadata = LinkedAccount;
/** @deprecated use the {@link LinkedAccountEmbeddedWallet} type instead. */
type PrivyEmbeddedWalletAccount = LinkedAccountEmbeddedWallet;
/** @deprecated use the {@link LinkedAccountEmbeddedWallet} type instead */
type EmbeddedWallet = LinkedAccountEmbeddedWallet;
/** @deprecated use the {@link LinkedAccountEthereumEmbeddedWallet} type instead. */
type PrivyEthereumEmbeddedWalletAccount = LinkedAccountEthereumEmbeddedWallet;
/** @deprecated use the {@link LinkedAccountSolanaEmbeddedWallet} type instead. */
type PrivySolanaEmbeddedWalletAccount = LinkedAccountSolanaEmbeddedWallet;
/** @deprecated use the {@link LinkedAccountBitcoinSegwitEmbeddedWallet} type instead. */
type PrivyBitcoinSegwitEmbeddedWalletAccount = LinkedAccountBitcoinSegwitEmbeddedWallet;
/** @deprecated use the {@link LinkedAccountBitcoinTaprootEmbeddedWallet} type instead. */
type PrivyBitcoinTaprootEmbeddedWalletAccount = LinkedAccountBitcoinTaprootEmbeddedWallet;
/** @deprecated use the {@link LinkedAccountSmartWallet} type instead. */
type PrivySmartWalletAccount = LinkedAccountSmartWallet;
/** @deprecated use the {@link LinkedAccountEmail} type instead. */
type PrivyEmailAccount = LinkedAccountEmail;
/** @deprecated use the {@link LinkedAccountPhone} type instead. */
type PrivyPhoneAccount = LinkedAccountPhone;
/** @deprecated use the {@link LinkedAccountEthereum} type instead. */
type PrivyEthereumAccount = LinkedAccountEthereum;
/** @deprecated use the {@link LinkedAccountSolana} type instead. */
type PrivySolanaAccount = LinkedAccountSolana;
/** @deprecated use the {@link LinkedAccountGoogleOAuth} type instead. */
type PrivyGoogleOauthAccount = LinkedAccountGoogleOAuth;
/** @deprecated use the {@link LinkedAccountTwitterOAuth} type instead. */
type PrivyTwitterOauthAccount = LinkedAccountTwitterOAuth;
/** @deprecated use the {@link LinkedAccountDiscordOAuth} type instead. */
type PrivyDiscordOauthAccount = LinkedAccountDiscordOAuth;
/** @deprecated use the {@link LinkedAccountGitHubOAuth} type instead. */
type PrivyGithubOauthAccount = LinkedAccountGitHubOAuth;
/** @deprecated use the {@link LinkedAccountSpotifyOAuth} type instead. */
type PrivySpotifyOauthAccount = LinkedAccountSpotifyOAuth;
/** @deprecated use the {@link LinkedAccountInstagramOAuth} type instead. */
type PrivyInstagramOauthAccount = LinkedAccountInstagramOAuth;
/** @deprecated use the {@link LinkedAccountTiktokOAuth} type instead. */
type PrivyTiktokOauthAccount = LinkedAccountTiktokOAuth;
/** @deprecated use the {@link LinkedAccountLinkedInOAuth} type instead. */
type PrivyLinkedInOauthAccount = LinkedAccountLinkedInOAuth;
/** @deprecated use the {@link LinkedAccountAppleOAuth} type instead. */
type PrivyAppleOauthAccount = LinkedAccountAppleOAuth;
/** @deprecated use the {@link LinkedAccountCustomJwt} type instead. */
type PrivyCustomJwtAccount = LinkedAccountCustomJwt;
/** @deprecated use the {@link LinkedAccountFarcaster} type instead. */
type PrivyFarcasterAccount = LinkedAccountFarcaster;
/** @deprecated use the {@link LinkedAccountPasskey} type instead. */
type PrivyPasskeyAccount = LinkedAccountPasskey;
/** @deprecated use the {@link LinkedAccountTelegram} type instead. */
type PrivyTelegramAccount = LinkedAccountTelegram;
/** @deprecated use the {@link LinkedAccountCrossApp} type instead. */
type PrivyCrossAppWalletAccount = LinkedAccountCrossApp;
type OAuthFlowState = {
    status: 'initial';
} | {
    status: 'loading';
} | {
    status: 'done';
} | {
    status: 'error';
    error: Error | null;
};
/**
 * @deprecated Use one of:
 * - `CreateEthereumEmbeddedWalletOpts`
 * - `RecoverEthereumEmbeddedWalletOpts`
 * - `CreateSolanaEmbeddedWalletOpts`
 * - `RecoverSolanaEmbeddedWalletOpts`
 */
type CreateOrRecoverEmbeddedWalletProps = string | undefined | {
    recoveryMethod: 'privy';
} | {
    recoveryMethod: 'user-passcode';
    password: string;
} | {
    recoveryMethod: 'recovery-encryption-key';
    recoveryKey: string;
} | {
    recoveryMethod: 'google-drive';
} | {
    recoveryMethod: 'icloud';
};
type CreateEthereumEmbeddedWalletOpts = string | undefined | {
    recoveryMethod: 'privy';
} | {
    recoveryMethod: 'user-passcode';
    password: string;
} | {
    recoveryMethod: 'recovery-encryption-key';
    recoveryKey: string;
} | {
    recoveryMethod: 'google-drive';
} | {
    recoveryMethod: 'icloud';
};
type RecoverEthereumEmbeddedWalletOpts = string | undefined | {
    recoveryMethod: 'privy';
} | {
    recoveryMethod: 'user-passcode';
    password: string;
} | {
    recoveryMethod: 'recovery-encryption-key';
    recoveryKey: string;
} | {
    recoveryMethod: 'google-drive';
} | {
    recoveryMethod: 'icloud';
};
type CreateSolanaEmbeddedWalletOpts = (undefined | {
    recoveryMethod: 'privy';
}) & {
    createAdditional?: boolean;
};
type RecoverSolanaEmbeddedWalletOpts = undefined | {
    recoveryMethod: 'privy';
} | {
    recoveryMethod: 'user-passcode';
    password: string;
} | {
    recoveryMethod: 'google-drive';
} | {
    recoveryMethod: 'icloud';
};
type SetRecoveryProps = {} | {
    recoveryMethod: 'user-passcode';
    password: string;
} | {
    recoveryMethod: 'google-drive' | 'icloud';
};
type RecoveryFlowState = {
    status: 'initial' | 'creating-wallet' | 'upgrading-recovery' | 'recovering';
};
type CustomAuthFlowState = {
    status: 'initial';
} | {
    status: 'loading';
} | {
    status: 'not-enabled';
} | {
    status: 'done';
} | {
    status: 'error';
    error: Error | null;
};
type MfaConfig = {
    relyingParty: string;
};

type IEmbeddedWalletConnectedState = {
    status: 'connected';
    provider: PrivyEmbeddedWalletProvider;
    account: LinkedAccountEthereumEmbeddedWallet;
};
type IEmbeddedWalletConnectingState = {
    status: 'connecting';
    account: LinkedAccountEthereumEmbeddedWallet;
};
type IEmbeddedWalletReconnectingState = {
    status: 'reconnecting';
    account: LinkedAccountEthereumEmbeddedWallet;
};
type IEmbeddedWalletDisconnectedState = {
    status: 'disconnected';
    account: null;
};
type IEmbeddedWalletNeedsRecoveryState = {
    status: 'needs-recovery';
    account: LinkedAccountEthereumEmbeddedWallet;
};
type IEmbeddedWalletNotCreatedState = {
    status: 'not-created';
    account: null;
};
type IEmbeddedWalletCreatingState = {
    status: 'creating';
    account: null;
};
type IEmbeddedWalletErrorState = {
    status: 'error';
    account: LinkedAccountEthereumEmbeddedWallet | null;
    error: string;
};
type EmbeddedWalletActions = {
    /**
     * @deprecated Use the `useRecoverEmbeddedWallet` hook instead.
     *
     * Recover the user's embedded wallet
     *
     * @param {{ recoveryMethod: 'user-passcode'; password: string }} User password: Preferred version with 'user-passcode' recovery method. Password is user-defined.
     * @param {{ recoveryMethod: 'google-drive' | 'icloud' }} Recovery provider: 'google-drive' or 'icloud' recovery method. Password is generated and stored on the cloud provider.
     * @returns {Promise<PrivyEmbeddedWalletProvider | null>} The EIP-1193 provider. If using google-drive recovery on Android, this will return null due to an Android bug with AuthSession. Use the `recoverWalletCallbacks` to handle wallet creation success in such cases.
  
     */
    recover: (args?: CreateOrRecoverEmbeddedWalletProps) => Promise<PrivyEmbeddedWalletProvider | null>;
    /**
     * Create an embedded wallet for this user.
     *
     * @param {{ recoveryMethod: 'user-passcode'; password: string }} User password: Preferred version with 'user-passcode' recovery method. Password is user-defined.
     * @param {{ recoveryMethod: 'google-drive' | 'icloud' }} Recovery provider: 'google-drive' or 'icloud' recovery method. Password is generated and stored on the cloud provider.
     * @returns {Promise<PrivyEmbeddedWalletProvider | null>} The EIP-1193 provider. If using google-drive recovery on Android, this will return null due to an Android bug with AuthSession. Use the `createWalletCallbacks` to handle wallet creation success in such cases.
     */
    create: (args?: CreateOrRecoverEmbeddedWalletProps) => Promise<PrivyEmbeddedWalletProvider | null>;
    /**
     * Return an EIP-1193 Provider for the Privy embedded wallet.
     *
     * @returns {@link PrivyEmbeddedWalletProvider} the EIP-1193 provider
     */
    getProvider: () => Promise<PrivyEmbeddedWalletProvider>;
    /**
     * @deprecated. Use `setRecovery` instead.
     * Set recovery password for a user's existing embedded wallet
     *
     * @param newPassword A user-defined password
     * @returns {Promise<PrivyEmbeddedWalletProvider>} The EIP-1193 provider.
     */
    setPassword: (password: string) => Promise<PrivyEmbeddedWalletProvider>;
    /**
     * @deprecated Use the `useSetEmbeddedWalletRecovery` hook instead.
     *
     * Sets recovery for a user's existing embedded wallet.
     *
     * @param {SetRecoveryProps} - An object containing the necessary properties for setting recovery.
     * @returns {Promise<PrivyEmbeddedWalletProvider | null>} - Returns a Promise that resolves to an EIP-1193 provider. If using Google Drive recovery on Android, this will return null due to an Android bug with AuthSession. Use the `setWalletRecoveryCallbacks` to handle wallet recovery setting success in such cases.
     */
    setRecovery: (args: SetRecoveryProps) => Promise<PrivyEmbeddedWalletProvider | null>;
};
type EmbeddedWalletConnectedState = EmbeddedWalletActions & IEmbeddedWalletConnectedState;
type EmbeddedWalletConnectingState = EmbeddedWalletActions & IEmbeddedWalletConnectingState;
type EmbeddedWalletReconnectingState = EmbeddedWalletActions & IEmbeddedWalletReconnectingState;
type EmbeddedWalletDisconnectedState = EmbeddedWalletActions & IEmbeddedWalletDisconnectedState;
type EmbeddedWalletNeedsRecoveryState = EmbeddedWalletActions & IEmbeddedWalletNeedsRecoveryState;
type EmbeddedWalletNotCreatedState = EmbeddedWalletActions & IEmbeddedWalletNotCreatedState;
type EmbeddedWalletCreatingState = EmbeddedWalletActions & IEmbeddedWalletCreatingState;
type EmbeddedWalletErrorState = EmbeddedWalletActions & IEmbeddedWalletErrorState;
type EmbeddedWalletState = EmbeddedWalletConnectedState | EmbeddedWalletConnectingState | EmbeddedWalletReconnectingState | EmbeddedWalletDisconnectedState | EmbeddedWalletNeedsRecoveryState | EmbeddedWalletCreatingState | EmbeddedWalletNotCreatedState | EmbeddedWalletErrorState;
type EmbeddedWalletStatus = EmbeddedWalletState['status'];

type IEmbeddedSolanaWalletConnectedState = {
    status: 'connected';
    /**
     * @deprecated instead, use `address` from `ConnectedEmbeddedSolanaWallet`.
     *
     * **NOTE: This field will be incorrect/inconsistent for any users with multiple embedded solana wallets**
     *
     * @example
     * const {wallets} = useEmbeddedSolanaWallet()
     * wallets[0].address
     */
    publicKey: string;
};
type IEmbeddedSolanaWalletConnectingState = {
    status: 'connecting';
};
type IEmbeddedSolanaWalletReconnectingState = {
    status: 'reconnecting';
};
type IEmbeddedSolanaWalletDisconnectedState = {
    status: 'disconnected';
};
type IEmbeddedSolanaWalletNeedsRecoveryState = {
    status: 'needs-recovery';
};
type IEmbeddedSolanaWalletNotCreatedState = {
    status: 'not-created';
};
type IEmbeddedSolanaWalletCreatingState = {
    status: 'creating';
};
type IEmbeddedSolanaWalletErrorState = {
    status: 'error';
    error: string;
};
type EmbeddedSolanaWalletActions = {
    /**
     * @deprecated Use the `useRecoverEmbeddedWallet` hook instead.
     *
     * Recover the user's embedded wallet
     *
     * @returns {Promise<PrivyEmbeddedSolanaWalletProvider | null>} The provider.
     */
    recover: () => Promise<PrivyEmbeddedSolanaWalletProvider | null>;
    /**
     * Create an embedded wallet for this user.
     *
     * @returns {Promise<PrivyEmbeddedSolanaWalletProvider | null>} The provider. If using google-drive recovery on Android, this will return null due to an Android bug with AuthSession. Use the `createSolanaWalletCallbacks` to handle wallet creation success in such cases.
     */
    create: (args?: CreateSolanaEmbeddedWalletOpts) => Promise<PrivyEmbeddedSolanaWalletProvider | null>;
    /**
     * @deprecated Use `wallets[0].getProvider()` instead.
     *
     * Return a provider for the Privy embedded wallet.
     *
     * @returns {@link PrivyEmbeddedSolanaWalletProvider} the Phantom provider
     */
    getProvider: () => Promise<PrivyEmbeddedSolanaWalletProvider>;
    /**
     * List of embeded solana wallets at each derived HD index.
     *
     * @returns {@link PrivyEmbeddedSolanaWalletProvider} the Phantom provider
     */
    wallets: ConnectedEmbeddedSolanaWallet[];
};
type ConnectedEmbeddedSolanaWallet = {
    address: string;
    publicKey: string;
    walletIndex: number;
    getProvider: () => Promise<PrivyEmbeddedSolanaWalletProvider>;
};
type EmbeddedSolanaWalletConnectedState = EmbeddedSolanaWalletActions & IEmbeddedSolanaWalletConnectedState;
type EmbeddedSolanaWalletConnectingState = EmbeddedSolanaWalletActions & IEmbeddedSolanaWalletConnectingState;
type EmbeddedSolanaWalletReconnectingState = EmbeddedSolanaWalletActions & IEmbeddedSolanaWalletReconnectingState;
type EmbeddedSolanaWalletDisconnectedState = Partial<EmbeddedSolanaWalletActions> & IEmbeddedSolanaWalletDisconnectedState;
type EmbeddedSolanaWalletNeedsRecoveryState = EmbeddedSolanaWalletActions & IEmbeddedSolanaWalletNeedsRecoveryState;
type EmbeddedSolanaWalletNotCreatedState = EmbeddedSolanaWalletActions & IEmbeddedSolanaWalletNotCreatedState;
type EmbeddedSolanaWalletCreatingState = EmbeddedSolanaWalletActions & IEmbeddedSolanaWalletCreatingState;
type EmbeddedSolanaWalletErrorState = EmbeddedSolanaWalletActions & IEmbeddedSolanaWalletErrorState;
type EmbeddedSolanaWalletState = EmbeddedSolanaWalletConnectedState | EmbeddedSolanaWalletConnectingState | EmbeddedSolanaWalletReconnectingState | EmbeddedSolanaWalletDisconnectedState | EmbeddedSolanaWalletNeedsRecoveryState | EmbeddedSolanaWalletCreatingState | EmbeddedSolanaWalletNotCreatedState | EmbeddedSolanaWalletErrorState;
type EmbeddedSolanaWalletStatus = EmbeddedSolanaWalletState['status'];

declare function isConnected(s: EmbeddedWalletState): s is EmbeddedWalletConnectedState;
declare function isConnected(s: EmbeddedSolanaWalletState): s is EmbeddedSolanaWalletConnectedState;
declare function isReconnecting(s: EmbeddedWalletState): s is EmbeddedWalletReconnectingState;
declare function isReconnecting(s: EmbeddedSolanaWalletState): s is EmbeddedSolanaWalletReconnectingState;
declare function isConnecting(s: EmbeddedWalletState): s is EmbeddedWalletConnectingState;
declare function isConnecting(s: EmbeddedSolanaWalletState): s is EmbeddedSolanaWalletConnectingState;
declare function isDisconnected(s: EmbeddedWalletState): s is EmbeddedWalletDisconnectedState;
declare function isDisconnected(s: EmbeddedSolanaWalletState): s is EmbeddedSolanaWalletDisconnectedState;
declare function isNotCreated(s: EmbeddedWalletState): s is EmbeddedWalletNotCreatedState;
declare function isNotCreated(s: EmbeddedSolanaWalletState): s is EmbeddedSolanaWalletNotCreatedState;
declare function isCreating(s: EmbeddedWalletState): s is EmbeddedWalletCreatingState;
declare function isCreating(s: EmbeddedSolanaWalletState): s is EmbeddedSolanaWalletCreatingState;
declare function hasError(s: EmbeddedWalletState): s is EmbeddedWalletErrorState;
declare function hasError(s: EmbeddedSolanaWalletState): s is EmbeddedSolanaWalletErrorState;
declare function needsRecovery(s: EmbeddedWalletState): s is EmbeddedWalletNeedsRecoveryState;
declare function needsRecovery(s: EmbeddedSolanaWalletState): s is EmbeddedSolanaWalletNeedsRecoveryState;

export { RecoverSolanaEmbeddedWalletOpts as $, AuthLinkSuccessCallback as A, PrivyTwitterOauthAccount as B, PrivyDiscordOauthAccount as C, PrivyGithubOauthAccount as D, ErrorCallback as E, FarcasterFlowState as F, GenerateSiweMessage as G, PrivySpotifyOauthAccount as H, PrivyInstagramOauthAccount as I, PrivyTiktokOauthAccount as J, PrivyLinkedInOauthAccount as K, LinkFarcasterInput as L, PrivyAppleOauthAccount as M, PrivyCustomJwtAccount as N, OtpLinkHookOptions as O, PasskeyFlowState as P, PrivyFarcasterAccount as Q, RecoveryFlowState as R, SiweFlowState as S, PrivyPasskeyAccount as T, PrivyTelegramAccount as U, PrivyCrossAppWalletAccount as V, WalletRecoveryCallbacks as W, CreateOrRecoverEmbeddedWalletProps as X, CreateEthereumEmbeddedWalletOpts as Y, RecoverEthereumEmbeddedWalletOpts as Z, CreateSolanaEmbeddedWalletOpts as _, AuthSuccessCallback as a, SetRecoveryProps as a0, CustomAuthFlowState as a1, MfaConfig as a2, EmbeddedWalletActions as a3, EmbeddedWalletStatus as a4, EmbeddedSolanaWalletActions as a5, EmbeddedSolanaWalletStatus as a6, isConnected as a7, isReconnecting as a8, isConnecting as a9, isDisconnected as aa, isNotCreated as ab, isCreating as ac, hasError as ad, needsRecovery as ae, PasskeyLinkHookOptions as af, PasskeyHookResult as ag, PasskeyLoginHookOptions as ah, SubmitPasskeyInput as ai, OtpLinkHookResult as b, OtpLoginHookOptions as c, OtpLoginHookResult as d, SubmitFarcasterOptions as e, LoginWithFarcasterInput as f, EmbeddedWalletState as g, EmbeddedSolanaWalletState as h, OtpFlowState as i, OAuthFlowState as j, SolanaWalletRecoveryCallbacks as k, PrivyUser as l, PrivyLinkedAccount as m, LinkedAccountWithMetadata as n, PrivyEmbeddedWalletAccount as o, EmbeddedWallet as p, PrivyEthereumEmbeddedWalletAccount as q, PrivySolanaEmbeddedWalletAccount as r, PrivyBitcoinSegwitEmbeddedWalletAccount as s, PrivyBitcoinTaprootEmbeddedWalletAccount as t, PrivySmartWalletAccount as u, PrivyEmailAccount as v, PrivyPhoneAccount as w, PrivyEthereumAccount as x, PrivySolanaAccount as y, PrivyGoogleOauthAccount as z };
